import React from "react";

export default function Data() {
  let originData = [
    {
      id: 0,
      title: "컴퓨터 공학",
      contents: `컴퓨터 공학(영어: computer engineering)은 컴퓨터 하드웨어 및 소프트웨어를 개발하는 데 필요한 전기공학 및 컴퓨터 과학의 여러 가지 분야를 통합하는 학문 분과이다. 현대 정보화 사회에서 컴퓨터의 하드웨어와 소프트웨어를 연구, 컴퓨터 시스템과 컴퓨터 관련 기술을 개발하여 익히고 이를 각 분야에 응용함을 목적으로 한다.

          하드웨어 부분에서 전자기학 이론 분야와 마이크로프로세서 분야, 전자 회로 분야로 나뉘고, 소프트웨어 부분에서 컴퓨터 과학 이론 분야와 컴퓨터 프로그래밍 분야, 컴퓨터 시스템 분야 등으로 나뉜다. 컴퓨터 과학과 전자공학이 연계되는 학문으로, 컴퓨터를 비롯한 전자제품이나 로봇 공학 등, 하드웨어와 소프트웨어 지식이 둘 다 필요한 분야들이 대표적이다.
          
          기초 분야: 전자기학, 회로, 이산수학, 자료 구조, 오토마타, 알고리즘 등 컴퓨터 기술을 발달시키기 위한 기반이 되는 논리를 다루는 부분.
          프로그래밍 분야: 컴퓨터 기술의 핵심을 이루는 분야로 C, C++, 자바 등 여러 가지 프로그래밍 언어로 컴퓨터에게 명령하여 작동시키는 기술을 연구.
          시스템 분야: CPU를 비롯한 컴퓨터의 하드웨어 구조와 컴퓨터 시스템을 구성하는 운영 체제, 네트워크 등을 취급.`,
    },
    {
      id: 1,
      title: "컴퓨터 하드웨어",
      contents: `컴퓨터 하드웨어(computer hardware, H/W, 순화 용어: 굳은모)는 케이스[1], 중앙 처리 장치, 모니터, 자판, 컴퓨터 기억 장치, 그래픽 카드, 사운드 카드, 메인보드와 같은 컴퓨터의 물리적 부품을 의미한다.[2] 입력, 연산, 제어, 기억, 출력 등 다섯 가지 기능을 구현하기 위해 컴퓨터는 여러 가지 부품들로 구성되어 있다. 이와 반대가 되는 용어는 소프트웨어이며 이는 특정 작업을 수행하기 위해 하드웨어에 의해 저장되고 실행되는 명령어를 의미한다.

          메인보드
          <nowiki /> 이 부분의 본문은 메인보드입니다.
          중앙 처리 장치(CPU)와 램 등을 꽂고, 확장 카드를 위한 슬롯을 가지고 있는 메인보드
          램(RAM) - 프로그램 실행과 순간 데이터 저장을 위한 공간으로, 하드 드라이브의 접근 횟수를 줄이는 역할을 한다. 보통 램이 많을수록 성능이 향상된다.
          버스:
          PCI 익스프레스 버스
          PCI 버스
          AGP
          VESA 로컬 버스
          EISA 버스
          ISA 버스
          USB (범용 직렬 버스)
          IDE, SCSI나 다른 유형에 대한 기억 장치 제어기로 하드 디스크, 플로피 디스크, CD-ROM 등을 제어한다. 제어기는 메인보드 내장이거나 확장 카드로 포함된다.
          컴퓨터 디스플레이에 출력을 제공하는 비디오 디스플레이 제어기
          프린터나 스캐너와 같은 외부 주변 장치와 연결하기 위한 컴퓨터 버스 제어기 (병렬 포트, 직렬 포트, USB, 파이어와이어)
          전원 공급 장치
          <nowiki /> 이 부분의 본문은 전원 공급 장치입니다.
          전원 공급기에는 변압기, 전압 조절기, 팬이 포함되어 있다.
          
          이동식 매체 장치
          <nowiki /> 이 부분의 본문은 기억 장치입니다.
          이동식 미디어 기록기는 이를테면 다음과 같다.
          
          CD - 가장 흔한 이동식 미디어이다.
          CD-ROM
          CD-RW
          CD-R
          DVD
          DVD-ROM
          DVD-RW
          DVD-R
          DVD-RAM
          DVD+RW
          DVD+R
          HD-DVD
          광자기 디스크
          블루레이 디스크
          플로피 디스크
          테이프 구동 장치 - 백업 용도이나 장기 기억 장치로 많이 사용
          2차 기억 장치
          내장형 기억 장치는 데이터를 저장하는 데 쓰인다.
          
          하드 디스크
          디스크 배열 제어기
          솔리드 스테이트 드라이브
          사운드 카드
          <nowiki /> 이 부분의 본문은 사운드 카드입니다.
          사운드 카드는 시스템 보드의 신호를 스피커에 아날로그 전압으로 출력한다.
          
          입출력 주변 기기
          <nowiki /> 이 부분의 본문은 주변기기입니다.
          추가적으로 하드웨어는 외부 부품들을 포함한다. 아래 항목들은 표준적이며 입출력을 위해 흔히 사용된다.
          
          입력기기
          키보드
          포인팅 장치
          마우스
          트랙볼
          조이스틱
          게임패드
          이미지 스캐너
          웹캠
          그래픽 태블릿
          출력기기
          프린터
          스피커
          모니터
          네트워킹 - 인터넷이나 다른 컴퓨터와 연결
          모뎀 - 전화 접속 연결
          네트워크 카드 - DSL/케이블 인터넷이나 다른 컴퓨터와 연결
          같이 보기
	위키미디어 공용에 관련된
미디어 분류가 있습니다.
컴퓨터 하드웨어
컴퓨터 구조
레가시 시스템
오픈 하드웨어
광 컴퓨터
DNA 컴퓨터
컴퓨팅 하드웨어의 역사`,
    },
    {
      id: 2,
      title: "자료 구조",
      contents: `자료구조(資料構造, 영어: data structure)는 컴퓨터 과학에서 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미한다.[1][2][3] 더 정확히 말해, 자료 구조는 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.[4] 신중히 선택한 자료구조는 보다 효율적인 알고리즘을 사용할 수 있게 한다. 이러한 자료구조의 선택문제는 대개 추상 자료형의 선택으로부터 시작하는 경우가 많다. 효과적으로 설계된 자료구조는 실행시간 혹은 메모리 용량과 같은 자원을 최소한으로 사용하면서 연산을 수행하도록 해준다.

      자료구조에는 여러 종류가 있으며, 이러한 각각의 자료구조는 각자의 연산 및 목적에 맞추어져 있다. 예를 들어 B-트리는 데이터베이스에 효율적이며, 라우팅 테이블은 네트워크(인터넷, 인트라넷)에 일반적이다.
      
      다양한 프로그램을 설계할 때, 어떠한 자료구조를 선택할지는 가장 우선적으로 고려되어야 한다. 이는 큰 시스템을 제작할 때 구현의 난이도나 최종 결과물의 성능이 자료구조에 크게 의존한다는 것을 많은 경험이 뒷받침하기 때문이다. 일단 자료구조가 선택되면 적용할 알고리즘은 상대적으로 명확해지기 마련이다. 때로는 반대 순서로 정해지기도 하는데, 이는 목표로 하는 연산이 특정한 알고리즘을 반드시 필요로 하며, 해당 알고리즘은 특정 자료구조에서 가장 나은 성능을 발휘할 때와 같은 경우이다. 어떠한 경우든, 적절한 자료구조의 선택은 필수적이다.
      
      이러한 관점은 알고리즘보다 자료구조가 보다 중요한 요소로 적용되는 많은 정형화된 개발론 그리고 프로그래밍 언어의 개발을 촉발시켰다. 대부분의 언어는 일정 수준의 모듈개념을 가지고 있으며, 이는 자료구조가 검증된 구현은 감춘 채 인터페이스만을 이용하여 다양한 프로그램에서 사용되는 것을 가능하게 해준다. C++, 자바와 같은 객체지향 프로그래밍 언어는 특별히 이러한 목적으로 객체를 사용한다.
      
      이러한 자료구조의 중요성으로 말미암아, 최근의 프로그래밍 언어 및 개발 환경은 다양한 표준 라이브러리를 제공하고 있다. 예로, C++의 표준 템플릿 라이브러리나 자바의 자바 API, 마이크로소프트 .NET과 같은 것들을 들 수 있다.
      
      자료구조에서 가장 기초적인 단위는 행렬, 레코드, 유니온, 참조와 같은 것이다. 예를 들어, Nullable 참조는 참조와 유니온의 조합으로 나타낼 수 있으며, 가장 단순한 자료구조 가운데 하나인 연결 리스트는 레코드와 Nullable 참조로 나타낼 수 있다.
      
      분류
      자료의 특성과 크기, 주요 사용법과 수행하는 연산의 종류, 구현에 필요한 기억 공간 크기에 따라 여러 가지 종류의 자료구조 중 하나를 선택할 수 있다. 자료구조의 종류로는 자료형의 따라 분류하는 단순 구조와 자료 간 관계가 1 대 1인 선형 구조, 1 대 다 혹은 다 대 다 구조인 비선형 구조, 마지막으로 파일 구조가 있다.[5]
      
      구현에 따라
      배열 - 가장 일반적인 구조이다. 메모리 상에 같은 타입의 자료가 연속적으로 저장된다. 자료값을 나타내는 가장 작은 단위가 자료를 다루는 단위이다.
      튜플 - 둘 이상의 자료형을 묶음으로 다루는 구조이다.
      연결 리스트 - 노드를 단위로 한다. 노드는 자료와 다음 노드를 가리키는 참조값으로 구성되어 있다. 노드가 다음 노드로 아무것도 가리키지 않으면 리스트의 끝이다.
      원형 연결 리스트 - 각 노드는 다음 노드를 가리키고, 마지막 노드가 처음 노드를 가리키는 연결 리스트이다.
      이중 연결 리스트 - 각 노드는 이전 노드와 다음 노드를 가리키는 참조값으로 구성된다. 처음 노드의 이전 노드와 마지막 노드의 다음 노드는 없다.
      환형 이중 연결 리스트 - 처음 노드가 이전 노드로 마지막 노드를 가리키고, 마지막 노드가 다음 노드로 처음 노드를 가리키는 이중 연결 리스트이다.
      해시 테이블 - 개체가 해시값에 따라 인덱싱된다.
      형태에 따라
      선형 구조
      스택 - 스택 자료구조에 먼저 저장된 것이 꺼내어 쓸 때는 제일 나중에 나온다. 반대로, 가장 최근에 저장된 것이 꺼내어 쓸 때는 제일 먼저 나온다. 만약, 자료들의 나열 순서를 바꾸고 싶다면 스택에 집어 넣었다가 꺼내면 역순으로 바뀐다.
      큐 - 스택과 반대로 큐 자료구조에 먼저 저장된 것이 제일 먼저 나온다. 반대로, 가장 나중에 저장된 것이 꺼내어 쓸 때는 가장 나중에 나온다.
      환형 큐 - 한정된 길이 안에서 부수적인 작업 없이 읽고 쓰기를 할 수 있는 큐이다.
      덱 - 양쪽에서 넣기와 빼기를 할 수 있는 일반화된 선형 구조이다.
      비선형 구조
      그래프 - 꼭짓점과 꼭짓점을 잇는 변으로 구성된다.
      유향 그래프, 무향 그래프 - 변이 방향성을 갖는지 갖지 않는지에 따른 그래프의 분류이다.무향 그래프의 경우, 순환이 없는 연결 그래프를 뜻한다. 유향 그래프의 경우 변의 방향은 보통 부모를 가리키도록 구현된다.
      트리 - 뿌리와, 뿌리 또는 다른 꼭짓점을 단 하나의 부모로 갖는 꼭짓점들로 이루어진 구조. 부모 자식 관계는 변으로 표현된다.
      * 이진 트리 - 자식이 최대 두 개인 트리.
      힙 - 이진트리의 일종으로 이진트리에 어떤 특성을 부여한 것이라 할 수 있다.
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      자료 구조
      데이터 모델`,
    },
    {
      id: 3,
      title: "학문",
      contents: `학문(學問, 영어: academic discipline)은 과거의 모든 사건과 일 중에서도 지식적인 부분들만 정리해놓은 지식체계이다. 혹은 그 지식을 익히는 행위도 포함하기도 한다. 학문을 익히기 위해선 지식을 다른 사람과 사물, 기록과 경험, 간접경험으로부터 얻어 배우고 이를 익혀서 체득하는 과정을 거친다. 지식, 기술과 가치를 얻기 위해 노력하고 이해하는 것이 필요하다. 학문은 교육을 통해 얻어질 수도 있지만 스스로의 탐구로도 이루어질 수 있다. 사회와 국가는 구성원을 학문을 통해 교육시키고 바른 품성과 문화의 발전을 이루도록 활동하도록 하여야 한다.

      학문을 연구하는 사람 또는 학문에 능통한 사람을 학자(學者, 영어: scholar)라고 부른다. 학문에서 주장 또는 사상, 철학 등을 달리 하는 갈래 또는 그러한 사람들의 모임을 학파(學派, 영어: school)라고 한다.
      
      학문과 과학
      학문과 과학을 비교할 때, 과학(科學, 영어: science)은 일반적인 용어인 학(學, 영어: study)이나 학문보다 엄밀한 뜻을 지닌다. 학문은 지식체계 자체를 뜻하나, 과학은 모든 지식은 존재의 합법칙과 논리적, 객관적, 이론적으로 이해해야 한다는 의미가 가미된 지식 체계라는 뜻이다.(스토리텔링) 그 대상에 따라 자연과학, 사회과학으로 나뉘지만, 자연과학만을 과학이라고 부르는 경우도 있다. 과학적 인식은 초경험적인 것의 가정(假定)을 허락하지 않으며, 사실의 관찰과 실험에 의해 합리성과 실증성을 철저히 일관시킨다. 그러나 논리로서는 귀납법과 연역법을 병용한다. 또한 과학적 인식은 단순한 개별적 인식의 집합이 아니라 그 사이의 법칙적 연관 체계이다.
      
      과학의 시조는 아리스토텔레스로 볼 수 있으나 현대 과학처럼 타당성과 실증성을 지니는 과학은 르네상스 이후에 먼저 수학적 자연과학으로서 태어났다. 이어 화학, 생물학이 발달했으며, 19세기에 이르러 사회과학이 태어났다. 일반적으로는 사회과학이라고 할 경우 인류학, 사회학, 경제학, 경영학, 정치학, 심리학, 지리학, 교육학, 법학 등을 가리킨다.[1]
      
      최근에는 인문학도 과학의 영역에 통섭하려는 움직임이 나타나고 있으나, 가시적인 성과는 나타나지 않고 있다. 과학적 방법론이 동원되고 있기는 하나, 인문학이 다루는 주제는 자연과학의 연구주제들처럼 구체적이고 물질적이지 않은 경우가 많기 때문이다. 인문학의 영역에는 철학, 역사학, 문학, 예술학, 비평 등이 포함되는 것으로 받아들여지고 있다.[2] 일부 학자들은 예술, 문예와 예술학, 문학은 다르며, 전자의 것들은 학문이 아니라고 규정해 구분하기도 한다. 이 경우 전자는 예술창작 행위로 한정되며, 후자는 그 '예술 현상'에 대해 연구하는 학문으로 규정된다.
      
      동양
      공자는 논어에서 '학이시습지면 불역열호아'(學而時習之 不亦說乎)라고 하여 '배우고 때로 익히면 또한 기쁘지 않겠는가'라고 하여, 학문의 길은 진정한 기쁨을 추구하는 방법임을 강조하였다.
      
      조동일은 학문은 진리를 탐구하는 행위라고 정의하면서, 진실이 무엇인가 바로 대답하려고 서두르지 않아야 학문 탐구를 올바르게 할 수 있다고 하였다.[3]
      
      학문의 분류
      문리학 - 언어학, 사학, 사회학, 지리학, 교육학, 경영학, 수학, 물리학, 화학, 생명학, 환경학, 천체학 등
      공학 - 기계학, 재료학, 생명학, 전기학, 전자학, 컴퓨터학, 토목학, 산업학 등
      의약학 - 심리학, 의학, 약학 등
      같이 보기
      학문 목록
      학습
      교육
      `,
    },
    {
      id: 4,
      title: "소프트웨어",
      contents: `컴퓨터 소프트웨어(computer software, 혹은 간단히 소프트웨어, 문화어: 쏘프트웨어, 순화 용어: 무른모)는 컴퓨터에게 동작 방법을 지시하는 명령어 집합의 모임이다.[1][2] 프로그램 소프트웨어는 컴퓨터 하드웨어에 직접 명령어를 주거나 다른 소프트웨어에 입력을 제공함으로써, 명령어의 기능을 수행한다. 컴퓨터 소프트웨어는 컴퓨터 하드웨어의 반대 의미로, 컴퓨터 하드웨어는 해당 일을 실제로 수행하는 시스템이다. 쉽게 설명하자면 생명체를 하드웨어라고 가정한다면, 그를 구성하는 유전자가 소프트웨어라고 생각할 수 있다.

          "소프트웨어"라는 용어는 1957년에 존 터키(John W. Tukey)가 처음 사용한 용어이다. 일상적으로 이 용어는 응용 소프트웨어의 의미로 자주 쓰인다. 컴퓨터 과학과 컴퓨터 공학에서 "컴퓨터 소프트웨어"는 컴퓨터 시스템, 프로그램, 데이터에 의해 처리된 모든 정보를 말한다.
          
          소프트웨어 대부분은 고급 프로그래밍 언어로 개발된다. 이 유형의 프로그래밍 언어는 프로그래머들에게 더 쉽고 더 효율적인데, 그 이유는 기계어보다 자연어에 더 가깝기 때문이다.[3] 고급 언어는 컴파일러나 인터프리터, 또는 이 둘의 조합을 이용하여 기계어로 변환된다. 소프트웨어는 컴퓨터의 기계어와 상당히 일치되는 저급 어셈블리어로도 개발이 가능하며 이는 어셈블러를 사용하여 기계어로 변환된다.
          
          역사
          <nowiki /> 이 부분의 본문은 소프트웨어의 역사입니다.
          소프트웨어의 최초의 장소가 되는 윤곽(알고리즘)은 계획된 해석기관을 위해 19세기 에이다 러브레이스가 작성하였다. 그러나, 해석기관이든 소프트웨어든 실제로 만들어진 것은 없었다.
          
          오늘날 우리가 인식하는 컴퓨터의 발명 이전의 소프트웨어에 대한 최초의 이론은 앨런 튜링이 1935년 수필 《Computable numbers with an application to the Entscheidungsproblem에서 제안되었다. (결정 문제)
          
          이는 컴퓨터 과학과 소프트웨어 공학의 양대 산맥이 탄생하는 계기가 되었으며, 둘 다 소프트웨어 및 소프트웨어의 제작에 대해 연구한다. 컴퓨터 과학은 더 이론적인 반면(튜링의 수필이 컴퓨터 과학의 한 예이다), 소프트웨어 공학은 더 실용적인 부분에 초점을 둔다.
          
          그러나 1946년 이전까지 우리가 알고있는 소프트웨어, 즉 저장식 프로그램 디지털 컴퓨터의 메모리에 저장되는 프로그램들은 존재하지 않았다. 최초의 전자식 컴퓨팅 장치들이 그 대신 이들을 다시 프로그램할 목적으로 재배치되었다.
          
          사용자가 보는 소프트웨어의 세 층
          사용자들의 시각은 보통 프로그래머의 시각과는 차이가 있다. 현대의 범용 컴퓨터(임베디드 시스템의 반대 의미)를 사용하는 사람들은 보통 소프트웨어를 플랫폼, 응용 프로그램, 사용자 소프트웨어의 세 층으로 분류한다.
          
          플랫폼 소프트웨어
          플랫폼이란 바이오스("소프트웨어" 대신 "펌웨어"라는 용어로 종종 설명되는), 장치 드라이버, 운영 체제, 그리고 대표적으로 그래픽 사용자 인터페이스 등을 총체적으로 포함하는 것으로, 컴퓨터와 주변기기가 서로 소통할 수 있게 만들어 준다. 플랫폼 소프트웨어는 대개 컴퓨터에 꾸러미로 같이 제공되며, 대개의 사용자는 그러한 것이 실제로 있는지, 아니면 선택할 수 있는 다른 플랫폼 소프트웨어가 존재하는지에 대해서 모르는 경우가 많다.
          응용 소프트웨어
          응용 프로그램은 사람들이 일반적으로 소프트웨어라고 생각하는 것이다. 대표적인 예로 오피스 제품군, 비디오 게임을 들 수 있다. 응용 소프트웨어는 보통 컴퓨터 하드웨어와는 별도로 구매한다. 어떤 응용 프로그램은 컴퓨터에 꾸러미로 제공되지만, 독립적인 응용 프로그램으로 수행된다는 점에서 차이가 없다. 응용 프로그램은 거의 대개 운영 체제와는 독립적인 프로그램이지만, 보통 특정 플랫폼만을 위해 제작된다. 사용자들은 흔히 컴파일러, 데이터베이스와 같은 "시스템 소프트웨어"를 응용 소프트웨어와 같이 여긴다.
          사용자 작성 소프트웨어
          사용자 소프트웨어는 사용자 특화된 요구를 충족시키기 위한 것이다. 사용자 소프트웨어에는 스프레드시트 템플릿, 워드 프로세서 매크로, 과학 시뮬레이션, 그래픽/애니메이션 스크립트 등이 있다. 심지어 전자우편 필터 역시 사용자 소프트웨어의 하나로 볼 수 있다. 사용자들은 이 같은 소프트웨어를 직접 제작하고도 그 중요성을 흔히 간과하곤 한다.
          <nowiki /> 다층 구조 문서를 참고하십시오.
          소프트웨어의 수행
          컴퓨터 소프트웨어는 컴퓨터의 저장장치("메모리" 또는 "램"으로 알려져 있음)로 "적재"되어야 한다.
          
          소프트웨어를 불러오면 컴퓨터는 소프트웨어를 작동할 수 있다. 컴퓨터는 컴퓨터 프로그램을 "실행"하여 작동시킨다. 여기에는 응용 소프트웨어에서 명령어를 보내는 과정이 포함되는데, 시스템 소프트웨어를 거쳐 궁극적으로 기계어 명령이 하드웨어에 전달된다. 각각의 명령어는 하나의 작업(데이터를 옮기거나, 계산 결과를 저장하거나, 명령의 흐름을 변경하는 등의)을 수행하도록 한다.
          
          기능에 따른 소프트웨어의 종류:
          실행 가능한 프로그램
          소스 코드 또는 스크립트
          구성
          소프트웨어 제작
          소프트웨어는 프로그래밍 언어와 관련 유틸리티를 사용하여 제작되는데, 다음과 같은 몇 가지 형태가 있다.
          
          스크립트 인터프리터와 같은 단일 프로그램: 컴파일러, 링커
          다른 도구를 포함한 패키지: 다양한 언어를 지원하며 편집기, 디버거와 다른 도구들을 포함한 대형 제품군(보통 통합 개발 환경[IDE]으로 불림).
          컴퓨터 프로그래밍, 소프트웨어 공학, 소프트웨어 구조, SaaS도 참조하라.
          
          소프트웨어 제작 때는 다음과 같은 컴퓨터 언어가 쓰인다.
          
          여담이지만 삼성 스마트폰의 터치 위즈를 구성하는 소프트웨어는 파이썬(Python) 으로 제작 되었다.
          
          B 언어
          C 언어
          C++
          C#
          비주얼 베이직
          D 언어
          코볼(COBOL)
          에이다(ADA) 등
          자바(JAVA)
          자바스크립트(JavaScript/JS)
          파이썬(Python)
          그리고 소프트웨어 제작할 때 쓰이는 프로그램은 다음과 같다.
          
          비주얼 스튜디오
          볼랜드 C++
          GCC 등
          소프트웨어 특허
          소프트웨어 특허에 대해서는 찬반이 엇갈린다. 특허가 "발명자"의 아이디어를 보호하는 반면에, 많은 이들이 이것이 소프트웨어 개발을 방해한다고 믿기 때문이다.
          
          법학적 관점에서의 소프트웨어
          대한민국의 소프트웨어산업진흥법에서는 소프트웨어를 "컴퓨터·통신·자동화 등의 장비와 그 주변장치에 대하여 명령·제어·입력·처리·저장·출력·상호 작용이 가능하도록 만드는 지시·명령(음성이나 영상정보를 포함한다)의 집합과 이를 작성하기 위하여 사용된 기술서 기타 관련 자료를 말한다."라고 정의한다.(법 제2조 1호)
          
          소프트웨어 라이선스
          <nowiki /> 틀:소프트웨어 배포 문서를 참고하십시오.
          소프트웨어에는 여러 종류의 라이선스 형태가 있다. 크게는 다음과 같이 나뉜다.
          
          프리웨어(freeware): 제작자가 라이선스만 지키면 마음껏 사용해도 된다.
          셰어웨어(shareware): 보통 30일 동안 소프트웨어를 정식 버전과 같은 기능을 사용할 수 있다.
          60일이나 90일 동안 사용할 수 있는 셰어웨어도 있다. 데모버전이라고도 한다.
          상용 소프트웨어(Commercial Software): 돈을 지불하고 사용권을 구매해서 사용해야하는 소프트웨어 라이선스의 한 분류이다. 기업에서 제작하는 대부분의 소프트웨어가 상용 소프트웨어에 속한다. 예로는 Microsoft의 Office, Oracle의 Oracle DB등이 있다. 상용 소프트웨어는 다시 Node locked license, floating license, per user license, per machine license와 같이 나뉠 수 있다.
          개발 단계에 따른 소프트웨어 분류
          소프트웨어 개발 단계에 따라 분류를 나눌 수 있다. 소프트웨어 배포자에 따라 이 소프트웨어 분류는 바뀔 수 있지만 일반적인 룰은 다음과 같다.
          
          알파 버전: 개발 주기에서 알파 버전의 경우 내부 테스트용으로 공개하는 경우가 많다. 거의 모든 주요 기능을 포함하고 있지만 많은 버그가 존재하고 실제 사용자가 도입해서 사용하기에는 무리가 있는 버전을 말한다. 베타 버전 이전의 단계이다.
          베타 버전: 베타 버전의 경우 알파에서 나온 문제점들을 수정한 단계이고 외부로 공개 테스트를 시작할 수 있을 정도의 완성도를 가진 소프트웨어를 말한다. 이후로는 새로운 기능보다는 나온 문제점들을 수정하고 UI를 최적화하는 작업을 진행한다.
          RC (Release Candidate): RC는 Microsoft에서 사용하는 소프트웨어 개발 단계로 정식판이 배포되기 직전의 단계로 볼 수 있다. 일반적으로 베타와 정식 배포판의 중간단계에 해당한다.
          Nightly build: 매일 발생하는 소프트웨어에 대한 수정사항을 포함하고 있는 소프트웨어 배포버전이다. 소프트웨어는 테스트가 되어 있지 않을 수 있기 때문에 매우 불안정한 상태이다.
          정식 버전
          같이 보기
응용 소프트웨어
모바일 응용 소프트웨어
컴퓨터 프로그래밍
프로그래밍 언어
텍스트 편집기
컴파일러
알고리즘
소프트웨어 개발과정
소프트웨어 개발도구
소프트웨어 유지보수
소프트웨어 최적화
API
소프트웨어 공학
소프트웨어 패키지
소프트웨어 라이선스
오픈 소스 소프트웨어
소프트웨어 저작권 침해
프리웨어
셰어웨어
교육용 소프트웨어
교수용 소프트웨어
학습용 소프트웨어`,
    },
    {
      id: 5,
      title: "전기공학",
      contents: `전기공학(電氣工學, electrical engineering)은 일반적으로 전기, 전자, 전자기의 연구 및 응용을 다루는 공학 분야이다. 전력, 통신, 제어, 정보 처리 등과도 관련되며, 넓은 의미로는 전자 공학과 무선 공학도 포함된다.

          현재 이 분야는 전신의 상용화와 전기 공급이 이루어진 뒤 19세기 말에 처음 증명되었다.
          
          역사
          전기는 적어도 17세기 초 과학계의 관심 대상이었다. 윌리엄 길버트는 저명한 초기 전기 과학자이며 자기와 정전기 간의 차이를 명확히 구별한 최초의 인물이다. 그는 "전기"라는 용어를 만들었다.[1]
          
          같이 보기
	위키미디어 공용에 관련된
미디어 분류가 있습니다.
전기공학
관련 국제 기구
국제 전기 표준 회의 (IEC)
전기 전자 기술자 협회 (IEEE)
전자공학
전자 설계 자동화 (EDA)
          `,
    },
    {
      id: 6,
      title: "컴퓨터 과학",
      contents: `컴퓨터 과학(영어: computer science, 컴퓨터 사이언스) 또는 전산학은 알고리즘 과정, 계산 기계 그리고 계산 자체에 대한 학문이다.

          컴퓨터 과학은 알고리즘, 계산 및 정보에 대한 이론적 연구에서부터 하드웨어와 소프트웨어의 계산 시스템 구현에 대한 실질적인 문제에 이르기까지 다양한 주제에 걸쳐 있다.
          
          전산 이론 및 시스템 설계를 다루는 전문가를 컴퓨터 과학자 또는 전산학자라 부른다.
          
          컴퓨터 과학의 분야는 이론적인 분야와 실용적인 분야로 나눌 수 있다. 예를 들어, 컴퓨터 그래픽스나 계산 기하학은 보다 구체적인 응용을 강조하는 반면, 계산 이론은 추상적인 계산 모델과 그것들을 사용하여 해결할 수 있는 일반적인 종류의 문제에 관한 것이다. 알고리즘과 데이터 구조는 컴퓨터 과학의 심장이라고 불려왔다. 프로그래밍 언어론은 계산 프로세스의 설명에 대한 접근 방식을 고려하는 반면, 컴퓨터 프로그래밍은 복잡한 시스템을 만들기 위해 그것들을 사용하는 것을 포함한다. 컴퓨터 구조는 컴퓨터 구성요소와 컴퓨터 작동원리를 설명한다. 인공지능은 인간과 동물에게서 발견되는 문제 해결, 의사결정, 환경 적응, 계획, 학습과 같은 목표 지향적인 과정을 종합하는 것을 목표로 한다. 디지털 컴퓨터는 다양한 정보 과정을 시뮬레이션할 수 있다. 컴퓨터 과학의 근본적인 관심사는 자동화할 수 있는 것과 없는 것을 결정하는 것이다. 컴퓨터 과학자들은 보통 학술 연구에 집중한다. 튜링상은 일반적으로 컴퓨터 과학에서 가장 뛰어난 상으로 인정받고 있다.
          
          large capital lambda	Plot of a quicksort algorithm
          Utah teapot representing computer graphics	Microsoft Tastenmaus mouse representing human-computer interaction
          컴퓨터 과학은 정보 및 전산의 이론적 기초와 그것의 구현 및 응용을 위한 실용적인 기술을 다룬다.
          컴퓨터의 이용
          1960년 전만 하더라도 컴퓨터는 이 세상에 존재하지 않았고 몇몇 선각자의 상상 속에서만 자리하고 있었다. 1946년 최초의 컴퓨터인 ENIAC이 출현한 이래 EDSAC·UNIVAC·MARK 등의 진보를 거쳐 작금에 이르러서는 정보화 사회·정보산업의 시대가 도래하였다. 폭발적인 수요확대로 초고속성장·진보를 거듭한 컴퓨터는 이용범위도 확대되어 산업사회의 다양한 분야에서 이용됨은 물론 일반 가정에서도 이용되고 있다. 제2차 대전 후 처음으로 산업에 이용되기 시작한 컴퓨터는 단순한 계산대체기능(計算代替機能)에서, 의사결정기능(意思決定機能)에 참여할 가능성을 보여주는 비약적인 발전을 보였고, 경영행동(經營行動)의 본질조차도 바꾸고 있다. 이러한 사실은 경영정보시스템(MIS) 지향(志向)의 많은 예에서 볼 수 있듯이, 기업에 있어서 컴퓨터 이용의 최종 목표로서의 전략적 의사결정으로의 효과적 이용을 다할 수 있는 가능성을 증대시키고 있음을 알 수 있다. 즉 커뮤니케이션 기술의 병행적 개발·이용의 진전과 더불어 컴퓨터는 직접 라인 업무의 일부로 되어 있고, 더욱이 수치제어(數値制御：numerical control) 등에서 실증되는 바와 같이 프로세스 제어의 활용분야를 확대하고 있다. 공정자동화, 사무자동화, 혁명으로 지칭되는 경영구조의 개선은 퍼스털 컴퓨터의 보급확대로 나타난 가정의 정보화와 연결되어 공공·금융·유통 서비스가 일체화된 사회·정보통신시스템을 구축하게 되어 원재료의 구매에서 판매시점에 이르는 총체적 관리와 EFTS(전자식 동시결제시스템)의 구축이 가능해진다. 이것은 프로그래밍의 개발의 가속화(加速化) 또는 문제 해결 기술의 진보로 컴퓨터가 기업경영에의 정착을 확고히 했다는 반증이다. 그러나 역시 계산기 개발상에서 애로가 되는 것은 소프트웨어(software)의 문제이며, 이와 같은 소프트웨어(software)·하드웨어(hardware) 또는 여러 인자간의 발전에 있어서 갭을 어떻게 메우느냐 하는 문제가 야기되어 결국 계산기를 독립적인 학문으로 연구·개발시키려는 계산기 과학이라는 새로운 학문이 태동되는 것이다.[1]
          
          용어
          이 말은 새크먼(H. Sackman)에 의하면 '컴퓨터 과학이란 수학·논리학·언어분석·프로그래밍·컴퓨터디자인·정보시스템·시스템스 엔지니어링 등의 공헌과 컴퓨터 개발과 이것의 응용에 관한 이론적·응용적인 훈련교육(訓練敎育)을 중심으로 광범위하게 걸친 연구분야이다'라고 정의한다. 그는 제2차 세계대전 후의 컴퓨터에 상관되는 모든 활동은 '컴퓨터 과학'이라고 하는 학제간연구(interdisciplinary) 영역을 형성하고, 급속한 발전을 가져온 것이라 하고, 1964년에 애치슨(W. H. Atchison) 및 햄블렌(G.W. Hamblen) 등이 개발한 상관영역도(相關領域圖)를 소개하였다. 컴퓨터 과학이라는 하나의 체계의 학문적 인정은 별문제로 하고 그것이 나날이 기성과학에의 참획(參劃), 공헌을 확대하여 인터디스플리너리한 특질을 급속히 변화시키고 있는 것은 명백하다. 애치슨 및 햄블렌은 '컴퓨터 과학'에 대해서 미국·캐나다·멕시코의 93개 대학을 대상으로 해서 앙케트 조사를 하였다. 그 결과로서 거의 모든 대학이 '정보과학'이나 '시스템 엔지니어링'보다 '컴퓨터 과학'이라는 용어를 더 선호하는 것으로 나타났다. 또 1965년 미국의 컴퓨팅기기협회(Association of Computer Machinery)는 이 협회가 조직한 컴퓨터 과학에 관한 커리큘렴(curriculum) 위원회의 권고서(勸告書)를 공개하고 컴퓨터 과학이 단지 컴퓨팅 디바이스나 수치계산의 기술(art)이 아니고, 물리학이 에너지에 관련되는 것과 같은 의의 이상으로 정보문제를 보다 광의(廣義)로 다루는 과학체계임을 논증하고 있다. 이에 관해서 1965년 9월에 캐나다의 서(西)온트리오 대학이 주최한 '시스템과 컴퓨터 과학 콘퍼런스'가 열렸다. 여기서 캐나다의 모든 대학에서의 컴퓨터 과학교육의 방향을 설정하는 토론이 있었고, 새로운 과학의 정의를 비롯해서 경계영역·교수방법 등의 연구·개발결과가 발표되었다. 그 성과의 일단으로서 컴퓨터 과학이 수치분석·응용통계·OR·데이터 처리 등의 여러 영역에 있어서 순수연구보다는 오히려 응용과학으로서의 프레임워크제에 서서의 설정을 목표로 하는 것이 명백해졌다. 또 이러한 전제에서 정보과학(information science)과 컴퓨터 과학의 상관성(相關性)에 관한 이론적 분석, 또는 컴퓨터 연구에 있어서의 이론과 응용간의 불균형 문제가 논구되었다. 이 콘퍼런스는 세계적으로 최초의 시도인 것으로 생각되는데 캐나다의 대학교육에서 '컴퓨터 과학'의 커리큘럼에의 편입은 다른 나라에 앞서는 것으로 보인다.[2]
          
          컴퓨터 과학의 정의의 문제점
          컴퓨터가 미국의 산업 사회에서도 불가결한 존재로서 실제로 많이 쓰이고 있는 것은 부정할 수 없는 사실이지만, '컴퓨터 과학'의 본질에 관한 학계의 논쟁은 아직도 활발하다. 이러한 논쟁과는 별도로 '컴퓨터 과학'에 관한 출판물은 그 정의(定義) 확립 이전에 많이 나와 있고, 이 현상은 MIS의 경우와 많은 유사점을 지닌다고 하겠다. 맥그로 힐(McGraw－Hill Book Co.)의 '컴퓨터 과학 문헌 안내'를 비롯해서 각 출판사가 컴퓨터 과학도서의 선전에 힘을 기울이고 있는 것도 사실이다. 그러면 '컴퓨터 과학'이라는 학문체계가 과연 존재하는가, 존재한다면 그 본질은 어떠한 것인가에 대한 문제점이 거론된다.[3]
          
          컴퓨터 과학의 본질
          1967년 사이먼(H. A. Simon) 교수는 이와 같은 기본적 의문에 대해서 뉴웰(A. Newell)·펠리스(A.G. Pelris)와의 연명으로 『사이언스』지의 공개장(公開狀)에서 다음과 같이 말했다. 그 내용을 요약하면, 현상(現象)이 있는 곳에는 이 현상을 기술하는 과학이 존재한다. 예컨대 식물학이 식물연구의 과학이고, 또 천문학이 별 연구를 목적으로 하는 과학인 것처럼 모든 과학은 현상에 의해서 창조된다. 따라서 컴퓨터가 있는 한, 컴퓨터를 연구하는 과학으로서의 '컴퓨터 과학'이 있어야 할 것이다. 컴퓨터를 둘러싼 환경,현상이 여러 갈래고 복잡하며 문제점이 다수 존재하는 오늘날, 그런 것의 과학적인 추구의 중요성은 다른 모든 과학의 그것에 비해 다름이 없음을 명백히 하고, 회의론자(懷疑論者)에 의해서 제기된 반론(反論)에 대해서, 논리적인 6가지 점을 열거하여 과학으로서의 정당성을 주장하고 있다. 우선, 자연현상만이 과학을 창조하며, 컴퓨터는 인위(人爲) 인공적인 데다 그에 대한 불변의 법칙이 없다. 따라서 과학적인 논거가 불비하다는 반론에 대해서는, 컴퓨터나 컴퓨터 프로그램은 나날이 발전하고 있고, 또한 컴퓨터의 정의(定義)는 명확하지 않으며, 그 뜻이 새로운 개발에 의해서 변화한다고 해도 과학의 현상, 영역은 모두 항상 변화하는 것이며, 컴퓨터 과학만이 그러한 것은 아니라고 하였다. 천문학도 당초에는 천체 사이의 가스는 그 영역 밖에 있었고, 물리학에도 방사선이 포함되지 않았으며, 심리학도 동물행동의 연구를 범위 외로 하였던 시대가 있었음을 지적하고, 또 수학이 지난날에는 '수량의 과학'이라고 정의되었던 사실을 예증(例證)하고 있다. '컴퓨터 과학'은 어디까지나 컴퓨터를 둘러싼 현상의 연구를 하려는 과학이지 컴퓨터를 온도계와 같이 단지 기기(機器)로서 파악하는 것을 부정한다. 그리고 과학을 일렉트로닉스나 수학·심리학 등의 분지과학(分枝科學)이라고 하는 반론에 대해서, 컴퓨터의 연구에는 위에 든 기존과학의 연구도 필요하다는 것을 긍정하면서도 현상이 과학의 중심(中心)을 정의하고 타과학과의 경계를 정의하는 것이 아니며, 그 예증(例證)으로서 생화학(生化學)이 동물학·화학의 어느 것의 존재도 부정하는 것이 아니라는 것을 지적하고 있다. 또 컴퓨터가 공학에 귀속하며, 과학의 대상이 될 수 없지 않은가라는 의문에 대해서는, 전기가 물리학과 공학, 식물(植物)이 식물학과 농학(農學)에 각각 상관되는 것과 같이 컴퓨터도 공학과 과학의 양자에 상관한다. '컴퓨터 과학'은 그것의 전문적인 과학으로서의 발전과정에서 더욱 더 분석(分析)과 가설(假設)과의 조합(組合), 순수연구와 애플리케이션 분석의 통합적(統合的) 그리고 상관적 전개를 통해서 학문적 체계의 특성을 명확히 할 필연성을 갖는다고 말하고 있다. 여하간 '컴퓨터 과학'이 생명력을 갖춘 컴퓨터의 추구를 목적으로 한 과학체계로서 발전할 것은 사실이며, 컴퓨터 과학자의 과제는 여러 인접과학자와의 상관활동을 활발히 하고, '컴퓨터 과학'으로 하여금 인간사회 진보를 위해 유효한 과학체계로서 공헌할 수 있도록 하는 데 있다고 할 수 있다.[4]
          
          역사
          컴퓨터 과학의 역사는 현대의 디지털 컴퓨터의 역사만을 가리키는 것이 아니다. 주판과 같이 계산을 수행하는 기계는 오래전부터 있었다. 1623년에는 최초의 계산기계가 만들어졌고, 찰스 배비지는 19세기 초에 차분기관을 만들었다. 1900년대에 들어서 IBM사가 펀치카드 시스템(PCS)을 개발하여 회계에 관련된 일을 하도록 보급하였다. 하지만 이들 모두는 주어진 한 가지의 일만 수행할 수 있었다.
          
          1920년 이전까지 '컴퓨터'(computer)는 계산(compute)을 담당하는 사무관을 일컫는 용어였다. 쿠르트 괴델, 알론조 처치, 앨런 튜링과 같은 컴퓨터 과학 초기의 학자들은 계산 가능성 문제(종이와 연필만을 가진 사무관이 철저하게 어떠한 지시에 따라 행동하여 계산할 수 있는 것들은 어떤 것들인가?)에 흥미를 느꼈다. 이러한 흥미는 계산이라고 하는, 지겨울 수도 있고 오류율이 높은 작업을 자동화하고자 하는 욕구로부터 비롯되었다. 그들은 이리하여 한 가지의 종류의 작업만 수행할 수 있었던 기존의 기계들과는 다른, 이론적으로 어떠한 계산도 가능한 기계를 만들고자 했다. 이러한 노력이 현대 컴퓨터 과학의 지평을 열었다.
          
          1940년대에 들어서자 더욱 강력한 기능을 지닌 계산기들이 등장했고, 이때부터 '컴퓨터'는 사람이 아닌 이들 기계를 부르는 용어로 굳어졌다. 컴퓨터가 단순한 숫자 계산보다 더 다양한 기능을 할 수 있는 것들이 알려지면서 컴퓨터 과학이라는 분야가 더욱 넓어지기 시작했다. 1960년대부터 여러 대학에 컴퓨터 과학 학과와 전공 과정이 생기면서 컴퓨터 과학이 학문으로 인정받기 시작하였으며, 학문의 쓰임새에 따라 세분되었다.
          
          미국의 컴퓨터 과학
          컴퓨터는 이제 '컴퓨터 만능'으로까지 지칭될 만큼 시대의 총아이며 미래의 청사진이기도 하다. 이미 독립적인 사고능력을 가진 컴퓨터가 나타나고 있는데, 미국의 경우에는 일리노이대학에서 컴퓨터와 인간간의 대화에 의해서 학습을 진행하는 CAI(Computer Aided Instruction) 시스템이 시도되고 있다. 특히 미국은 정부 민간기업체 차원에서 컴퓨터 과학연구개발을 위해 대학 또는 민간연구단체에 막대한 재정지원과 프로젝트를 추천해 오고 있다. 이에 따라 미국의 학계에서 커리큘럼 속에 인터디시플리너리적 과학으로서의 컴퓨터 과학 강좌를 설치할 것을 검토하였으며, 컴퓨터 시대에 대응하기 위한 대학의 역할에 적극적인 자세를 보이고, 이 몇 해 동안에 유명한 대학의 경영대학원에서 컴퓨터 강좌를 병설하는 곳이 증가하고 있다. 또한 많은 컴퓨터 사이언스 담당교수가 있다고 한다. 예컨대 사이먼(H.A. Simon) 교수는 1966년 이후 컴퓨터 사이언스 심리학담당 교수로 활약하고 있다. 또한 OR의 세계적 권위자이며 파이어니어인 스탠포드대학의 단치히(G.H. Dantzig) 박사도 컴퓨터 사이언스를 강의하고 있다. 경영과학(managment science)의 여러 기법(技法)과 컴퓨터와의 연동(連動)을 전제로 한 문제해결법(problem solving)의 발전이 컴퓨터 효과의 증대에 기여할 가능성을 크게 나타내고 있는데도 불구하고 '컴퓨터 과학'의 침투가 늦어지고 있는 이유로서는 ① 경영과학의 응용성의 결여, ② 인터디시플리너리한 어프로치에 있어서의 통합이론(統合理論), 또는 기술상의 미(未)발달 등을 들 수 있다 다시 말해서 경영관리의 환경 적응성의 이론적 프레임워크의 설정 곤란, 교육시스템의 개발 지체에 있는 것이다. 이 문제를 고려함에 있어 정보과학 또는 MIS의 발달과정을 정사(精査)하는 것도 중요하다. 즉 MIS의 조속한 이용을 기대한 경영자의 실망에 비추어 보아 컴퓨터 사이언스에 대한 의문이나 재고(再考)의식이 나온 것도 부정할 수 있다. 컴퓨터 과학을 둘러싼 논의가 활발해졌지만, 그 전체로서 컴퓨터 과학이 경영관리의 혁신에 있어서 진실로 가치 있는 과학체계임을 명백히 할 필요가 있다. 따라서 캐나다의 컴퓨터 교육의 발전을 논하기 이전에 미국에서의 논쟁을 추적함으로써 그 본질과 방향에 대해 고찰하는 것도 중요한 일이 되겠다.[5]
          
          다른 분야와의 관계
          컴퓨터 과학은 오늘날 많은 사람들이 사용하는 컴퓨터라는 기계에 대한 학문으로 한정되지 않는다. 유명한 컴퓨터 과학자 에츠허르 데이크스트라는 "컴퓨터 과학에서 컴퓨터란, 천문학에서 망원경 이상의 것이 아니다."라고 하였다.
          
          컴퓨터 과학 연구는 수학, 인지 과학, 물리학, 그리고 언어학과 같은 학문과 공생한다.
          
          많은 과학 분야와 비슷하게 컴퓨터 과학도 수학과 가장 밀접한 관계를 가지고 있을뿐만 아니라, 수학에 기초를 둔 과학의 한 분야이다. 컴퓨터 과학의 기초에 큰 영향을 미친 수학이 조지 불의 불 대수이다. 불 대수는 이진법을 기반으로 한 대수학으로, 그 외에 체론과 환론 또한 중요한 영향을 미쳤다. 초기의 컴퓨터 과학은 쿠르트 괴델과 앨런 튜링 등의 수학자들이 큰 영향을 끼쳤고, 수리논리학, 범주론, 도메인 이론, 대수학과 같은 수학 분류들은 컴퓨터 과학과 함께 발전하고 있다.
          
          스탠 켈리-부틀은 "과학과 컴퓨터 과학의 관계는 유체동력학과 납공업의 관계와 같다"라고 말하였다. 이는 컴퓨터 과학이 과학의 특성을 충분히 갖지 않는다는 오해에 기인한다. [출처 필요]
          
          컴퓨터 과학과 소프트웨어 공학의 관계에 대해서는 논란이 많다.[출처 필요] 컴퓨터 과학과 소프트웨어 공학의 용어 정의가 많은 사람들에게 다소 모호하게 보이기 때문이다. 소프트웨어 공학은 컴퓨터 과학의 한 분야에 불과하다고 말하는 사람들이 있는 반면, 소프트웨어 공학은 다른 분야에 대한 응용이나 자원을 운용하는 방법 등 실용적인 특징에서 컴퓨터 과학의 다른 분야와 잘 구분된다.
          
          컴퓨터 과학과 경영 관리
          사이먼은 컴퓨터와 사상의 관계에 대해서 '컴퓨터가 인간의 이미지에 따라서 조직되는 것이라면, 컴퓨터는 명백히 인간행동에 대한 택일적(擇一的) 조직상(組織上)의 가설에서 생기는 결과를 개발하는 기기(機器)이다'라고 말하고, 인간행동의 깊은 이해를 얻기 위한 수단으로서의 컴퓨터 시뮬레이션(computer simulation)의 중요한 역할과 의의를 밝히고 있다. 이 뜻을 경영관리의 향상이라는 관점에서 파악할 경우, 맨머신 시스템(man-machine system)의 원의(原義)가 밝혀질 것으로 생각되지만, 컴퓨터의 본질과 적용분야의 과학적 추구를 적극화하고, 컴퓨터에 대한 투자의 최적 효과의 창출에 체계적으로 노력함이 경영관리의 도전적 과제라고 이해할 수 있다. 또 이와 같은 방향설정이 긍정된다면, 경영교육 커리큘럼 편성에 있어서의 '컴퓨터 과학'의 위치 설정도 명백해질 것으로 생각되지만, 교육기간은 말할 것도 없고, 기업조직에서 과학으로서의 컴퓨터 사고(思考)는 가속적(加速的) 보편화를 이룰 것이 명확하다. 경영관리에 대한 컴퓨터의 임팩트(impact)의 본질적 이해와 대응책도 컴퓨터의 과학적 추구에 크게 의존할 것이라는 점을 강조함과 동시에 '컴퓨터 과학'이 경영학 혁신의 에이전트(agent)적 기능을 다할 것이라는 점을 지적해야 한다.[6]
          
          분야
          컴퓨터 과학은 그 이론의 적용법에 따라 여러 분야로 나뉜다. 일반적인 분류는 다음과 같다.
          
          인접 학문
          정보철학
          정보심리학
          인지과학
          언어학
          사이버네틱스
          바탕이 되는 이론
          이산수학
          정보이론
          수리논리학
          도메인 이론
          확률론과 통계학
          암호학
          이론 컴퓨터 과학
          계산 이론
          그래프 이론
          최적화 이론
          오토마타 이론
          유형 이론
          양자 컴퓨팅
          계산 가능성 이론
          형식언어
          알고리즘과 자료 구조
          알고리즘
          알고리즘 분석
          확률적 알고리즘
          자료 구조
          계산기하학
          조합 최적화
          프로그래밍 언어론과 정형 기법
          프로그래밍 언어
          유형이론
          컴파일러
          자동 정리 증명
          병행·병렬·분산 컴퓨팅
          병렬 컴퓨팅
          그리드 컴퓨팅
          병행 컴퓨팅
          병행성
          분산 컴퓨팅
          소프트웨어 공학
          소프트웨어 공학
          컴퓨터 프로그래밍
          컴퓨터 구조, 운영 체제
          컴퓨터 구조
          마이크로아키텍처
          명령어 집합 구조
          다중 처리
          운영 체제
          실시간 컴퓨팅
          네트워크
          컴퓨터 네트워크
          인공지능
          자동 추론
          로보틱스
          컴퓨터 비전
          기계 학습
          진화 연산
          자율 컴퓨팅
          패턴 인식
          지식 표현
          강화 학습
          심층 학습
          인공 신경망
          떼 지능
          게임이론
          Algorithmic game theory
          인공생명
          데이터베이스
          데이터베이스
          데이터 마이닝
          검색 엔진
          컴퓨터 그래픽스와 시각화
          2차원 컴퓨터 그래픽스
          3차원 컴퓨터 그래픽스
          컴퓨터 애니메이션
          렌더링
          혼합 현실
          가상 현실
          솔리드 모델링
          이미지 처리와 음향 처리
          FFT 알고리즘
          이미지 처리
          음성 인식
          데이터 압축
          음성 합성
          소셜 컴퓨팅과 인간과 컴퓨터 상호 작용
          소셜 컴퓨팅
          인간과 컴퓨터 상호작용
          계산과학
          수치해석학
          계산생물학
          계산물리학
          계산화학
          생물정보학
          신경정보학
          계산신경과학
          기호계산
          프로그래밍 패러다임
          함수형 프로그래밍
          명령형 프로그래밍
          선언형 프로그래밍
          객체지향 프로그래밍
          절차적 프로그래밍
          같이 보기
          컴퓨터과학자
          컴퓨터과학자 목록
          튜링상
          ACM
          컴퓨터 공학`,
    },
    {
      id: 7,
      title: "정보화",
      contents: `정보화(情報化, digitization)는 어떤 지역이나 분야가 정보를 중시하는 방향으로 변화하는 과정을 말한다. 문명의 발전 단계에서 농경시대, 산업시대, 정보시대로 나누어 볼 수 있는데, 원시시대에서 농경시대로 진행되는 과정을 농경화, 농경시대에서 산업시대로 진행하는 과정을 산업화라고 하듯이 정보시대로 진행하는 과정을 정보화라고 할 수 있다.

      `,
    },
    {
      id: 8,
      title: "하드웨어",
      contents: `하드웨어(hardware)는 다음 등을 가리킨다.

      가전 철물(household hardware)
      컴퓨터 하드웨어(computer hardware): 컴퓨터의 물리적 부품↔컴퓨터 소프트웨어
      전자 부품(Electronic component): 기본 전자회로 구성품
      디지털 회로(Digital electronics): 디지털 신호를 이용하는 전자 회로
      병기 기술(Military technology): 병기의 제조, 사용법 등의 군사 기술
      하드웨어 공학(Hardware engineering): 컴퓨터 하드웨어 및 소프트웨어를 개발하는 데 필요한 전기공학 및 컴퓨터 과학의 여러 가지 분야를 통합하는 학문 분과
      `,
    },
    {
      id: 9,
      title: "컴퓨터",
      contents: `컴퓨터(영어: computer, 문화어: 콤퓨터, 콤퓨타, 순화어: 전산기, 셈틀)는 방대한 양의 데이터와 정보를 저장하고 처리할 수 있는 전자적 기계 장치이다. 정보를 저장, 검색, 정리, 수정하기 위해 프로그램을 사용한다. 즉, 산술이나 논리셈, 계산을 자동으로 수행하고 텍스트, 그래픽, 심벌(특수 문자나 부호), 사운드 등을 처리하도록 프로그래밍할 수 있는 범용장치(programmable machine)다. 전자회로와 이진법' 이용하여 프로그램과 정보를 전자적 형태로 저장하고 빠르게 계산(연산)하고, 입력된 데이터를 정해진 과정(프로그래밍)에 따라 처리하고 정보로 출력하고 제어한다. 수식이나 논리적 언어로 표현된 일련의 산술 연산이나 논리 연산을 자동적으로 수행하도록 지시하거나 입력된 터를 가공(저장)하고 처리된 데이터를 유용한 정보로 출력한다. 사전에서 찾을 수 있는 위와 같은 정의는 정확하지만 가리키는 범위가 너무 넓어 이전의 컴퓨터와 현재의 컴퓨터 그리고 미래의 컴퓨터를 쉽게 설명하기는 어렵다. 더 의미있는 질문은 '컴퓨터의 종류에는 어떤 것들이 있는가?' 아니면 '현재의 컴퓨터의 성능과 특별한 기능은 무엇인가?'일 것이다.[출처 필요]

      파스칼은 세무사였던 아버지의 작업을 돕기 위해 덧셈과 뺄셈을 자동으로 수행하는 기계식 계산기를 고안했다. 1950년대 초에 '컴퓨팅 머신'(computing machine)이라는 말이 전산기를 지칭하는 단어로 쓰였다. 마침내, 더 짧은 '컴퓨터'라는 말이 컴퓨팅 머신을 대체했다. 본래, 산술은 수학적인 문제와 밀접하게 연관되어 있지만, 현대 컴퓨터들은 값이 싸지고 용도가 다양해짐에 따라, 수학과는 관계 없는 많은 일에도 쓰인다.
      
      어원
      A human computer.
      현미경과 계산기를 갖춘 휴먼 컴퓨터, 1952
      '컴퓨터'(computer)라는 명칭의 유래는 먼저 계산한다는 뜻의 라틴어 '콤푸타레'(computare)에서 유래했다. 이 단어의 어근은 '콤'(com)과 '푸투스'(putus)로 '함께'(com)와 '생각하다'(putus)의 합성어이다. '생각을 정리하며 수식을 따라 계산하는 것'을 의미한다. 컴퓨터라는 말의 의미는 시대에 따라 변화했다. 영어에서 '컴퓨터'는 우선적으로 계산하는 사람을 의미한다. 과거에는 기계적인 도움의 유무에 관계없이 수학 계산을 수행하는 사람을 가리키는 말로 사용하였다. 현재에는 기계를 의미하는 경우가 더 많지만 여전히 수학 계산하는 사람으로도 사용한다. ODE2 목록에 따르면 1897년에 처음으로 기계적 계산을 수행하는 기계를 일컫는 말로 사용되었다. 1946년까지 여러 수식어가 소개되었는데, 이것들은 여러 종류의 컴퓨터를 구별하기 위한 것들이었다. 이 수식어들은 아날로그, 디지털을 포함하고 있다.
      
      한국어로의 순화어로는 셈을 하는 틀이라는 셈틀이 있다.
      
      컴퓨터의 기능
      전자회로를 이용하여 자동적으로 계산이나 데이터를 처리하는 기계로 프로그래밍이 가능하다. 입력자료를 받아들여 처리하고 그 정보를 저장하고 검색하여 결과를 출력하는 일을 하며 다른 기계들을 제어(control other machines)하기도 한다. 아날로그형과 디지털형이 있으나 1960년 이후로는 거의 디지털형만이 이용된다. 컴퓨터는 여러 가지 명령어로 구성된 프로그램의 지시에 따라 입력한 데이터를 분석·처리하여, 그 결과를 사용자에게 제공한다. 그러나 컴퓨터가 하나의 업무를 처리하기 위해서는 입력·제어·기억·연산·출력 등의 다섯가지 장치가 서로 밀접하게 연관되어야만 종합적인 기능을 수행할 수 있다.
      
      입력
      프로그램을 컴퓨터 내부의 메모리로 읽어들이는 입력 장치의 기능이다.
      
      제어
      프로그램의 명령을 하나씩 읽고 해석하여, 모든 장치의 동작을 지시하고 감독·통제하는 기능이다. 제어 기능은 컴퓨터에서 가장 핵심적인 기능으로 이러한 제어 기능이 있기 때문에 컴퓨터는 자동성을 갖는다. 제어 기능은 중앙 처리 장치(CPU)의 제어부에서 담당한다.
      
      기억 및 저장
      입력 장치로 읽어들인 데이터나 프로그램, 중간 결과 및 처리된 결과를 기억하는 기능으로서 중앙 처리 장치의 주기억 장치와 보조 기억 장치에 갖추어져 있다. (HDD (SSD)와 RAM 이 여기에 속한다.)
      
      연산
      기억된 프로그램이나 데이터를 꺼내어 산술이나 논리셈따위를 하는 기능으로서 중앙처리장치(CPU)의 연산부에서 담당한다.
      
      출력
      프로그램의 결과를 빛, 화면, 소리, 잉크 등의 수단으로 출력하는 장치의 기능이다. (모니터, 프린터, 플로터 등이 여기에 속한다.)
      
      역사
      <nowiki /> 컴퓨터의 역사 문서를 참고하십시오.
      고대로부터 주판을 비롯해 계산을 돕는 많은 도구들이 있었다. 중세에 들어와서는 유럽과 서남아시아 지역에서 천체의 움직임을 예측하거나 낮과 밤의 길이를 계산하기 위한 정밀한 기계식 계산기가 발명되었으나, 천체 관측 외의 계산에는 사용할 수 없었다.
      
      1623년 독일의 학자 빌헬름 시카르트가 6자리 숫자의 덧셈과 뺄셈을 수행할 수 있는 최초의 기계식 계산기를 발명하였다. 최초의 기계식 계산기 모델은 제작 도중 화재로 소실되었으나, 두 번째 모델은 사용법을 담은 편지와 함께 시카르트의 친구였던 천문학자 요하네스 케플러에게 보냈다. 시카르트의 기계식 계산기는 천체운동을 당시 천문학 수준에 비해 훨씬 정확하게 계산하는데 도움을 준 것으로 추정된다.
      
      1642년에 당시 19세였던 블레즈 파스칼이 10진수의 덧셈과 뺄셈을 계산할 수 있는 기계식 계산기를 발명[1]하여 약 20대를 제작하였고, 1672년 고트프리트 빌헬름 라이프니츠는 이 계산기를 곱셈과 나눗셈이 가능한 기계로 개선하였다. 라이프니츠는 또한 현대 디지털 컴퓨터의 핵심적인 부분이 된 이진법을 고안하였다.
      
      1822년 영국 수학자 찰스 배비지는 다항 함수와 로그 함수, 삼각함수 등을 계산할 수 있는 기계식 계산기인 차분기관을 설계하였으나, 당시의 기술로는 비용이 너무 비싸 이 기계의 실물은 1855년에 이르러서야 제작되었다. 한편 배비지는 1835년에 그의 차분기관을 보다 발전시킨 해석기관을 설계하였으나, 당시 기술로는 기계의 제작이 너무 복잡하고 부품을 제작하기가 어려워 이 기계의 실물은 만들어지지 않았다. 비록 설계뿐이지만 많은 학자들은 해석기관을 최초의 프로그래밍 가능한 컴퓨터로 인정하고 있다.
      
      1936년 현대 컴퓨터 과학의 아버지라 불리는 영국의 수학자 앨런 튜링은 튜링 기계라는 수학적 개념을 고안하여 알고리즘과 계산에 관한 이론적 기초를 정립하였다. 그는 알려진 모든 수학적 개념과 계산 과정을 튜링 기계를 통해 나타낼 수 있음을 증명하였다. 인간에게 알려진 모든 계산 기계는 계산 속도의 차이가 있을 뿐 모두 튜링 기계와 같거나 약한 계산 능력을 가진다.
      
      1937년 벨 연구소에서 일하고 있던 미국의 수학자이자 물리학자 조지 스티비츠는 이진법을 사용하는 최초의 전자식 디지털 계산기를 개발하였다. 1939년에는 선형대수학의 문제를 풀기 위해 개발된 전자식 디지털 컴퓨터인 아타나소프-베리 컴퓨터가 개발되었으나 다른 용도로 프로그래밍할 수 없었으므로 다른 목적으로 사용할 수는 없었다.
      
      한편, 1941년 독일의 공학자 콘라드 추제는 천공 카드로 프로그래밍할 수 있는 최초의 전자/기계식 컴퓨터인 Z3를 개발하였다. 그러나 콘라드 주제는 당시 적국이었던 미국이나 영국 과학자들과 거의 교류가 없었고 Z3의 실물 또한 2년 후 연합군의 폭격으로 파괴되었기 때문에 그의 업적은 독일 바깥에는 오랫동안 알려지지 않았다. 프로그래밍이 가능한 최초의 전자식 디지털 컴퓨터는 2차 대전 당시 독일의 암호를 해독하기 위해 설계된 영국의 콜로서스였다. 그러나 이 컴퓨터의 존재는 1급 비밀이었으므로 1970년대까지 일반인에게는 알려지지 않았다.
      
      이러한 이유로 1946년에 미국에서 개발된 에니악(ENIAC)은 오랫동안 최초의 프로그래밍 가능한 범용 컴퓨터로 알려져 있었다. 에니악은 18,000개의 진공관을 이용하여 무게가 30톤에 이르렀고, 가격은 50만 달러(최근 대한민국 물가로 약 70억원)에 달했기 때문에, 포탄의 궤적을 계산하거나 수소폭탄의 폭발을 예측하는 등 주로 정부에서 군사적 목적으로 이용되었다.
      
      한편 1945년 미국의 컴퓨터 과학자 존 폰 노이만은 프로그램을 기억장치에 내장하는 방식의 컴퓨터를 제안하였고 그의 제안을 바탕으로 EDVAC이 설계되었으나 특허권 문제로 개발이 늦어졌다. 그리하여 1949년 EDVAC의 설계를 발전시킨 EDSAC이 최초로 프로그램 내장방식과 이진법을 채택한 디지털 컴퓨터가 되었다.
      
      1970년대 말부터 개인용 컴퓨터(PC)가 보편화되기 시작했다. 1990년 이후로 18개월에서 24개월을 주기로 성능이 두 배씩 향상되는 폭발적인 발전이 있었다.
      
      대한민국의 컴퓨터 도입 역사
      한국은 1967년 경제기획원이 IBM 1401 컴퓨터를 도입하여 인구조사결과를 컴퓨터로 처리한 것을 시작으로 컴퓨터를 다방면에 널리 사용되게 되었다.
      
      컴퓨터의 대중화 배경
      1980년대 IBM사의 대형컴퓨터 위주였던 컴퓨터 시장은 MS사가 개발한 윈도 제품의 성공으로 컴퓨터의 대중화가 시작되었다. 그 뒤로 개인용 컴퓨터의 수요는 대형컴퓨터 시장 수요를 추월하게 되었다. 즉 컴퓨터의 대중화를 가능하게 한 주요 배경은 성능의 우수성과 저가격화, 그리고 소프트웨어의 발전이라 할 수 있다.
      
      분류
      분류
      마이크로컴퓨터
      미니컴퓨터
      워크스테이션
      대형 컴퓨터
      슈퍼컴퓨터
      메인프레임
      개인용 컴퓨터 (PC)
      노트북 컴퓨터
      개인 정보 단말기 (PDA)
      착용형 컴퓨터
      
      규모에 따른 분류
      크기	형태	비고
      임베디드(내장형)컴퓨터	아두이노, 웨어러블 컴퓨터	
      초소형저전력pc	라즈베리파이, 오드로이드, 스마트폰	사이즈9cm x 6cm 전후, 전력5v[2]
      데스크톱(탁상용)	워크스테이션, 개인용 컴퓨터(PC), 노트북 컴퓨터	
      대형 슈퍼컴퓨터 및 서버급	슈퍼컴퓨터, 서버급 컴퓨터	
      제조 기술에 따른 분류
      직렬 컴퓨터 (Serial Computer)
      병렬 컴퓨터 (Parallel Computer)
      수행 능력에 따른 분류
      범용 컴퓨터(General-purpose Computers)
      특수 목적 컴퓨터(Special-purpose Computers)
      단일 목적 컴퓨터(Single-purpose Computers)
      운영 체제에 따른 분류
      운영 체제의 종류에 따라 사용자가 이용할 수 있는 프로그램의 종류가 크게 달라지고 이용 방식 또한 달라지므로, 운영 체제에 따른 분류가 실용적인 분류로 자주 사용된다.
      
      윈도우
      매킨토시
      유닉스
      리눅스
      구성
      크게 논리적 지시 사항인 소프트웨어(S/W; Software)와 물리적 장치인 하드웨어(H/W; Hardware)로 나눌 수 있으며, 컴퓨터의 하드웨어는 중앙 처리 장치(CPU)와 주기억 장치(RAM) 및 입력 장치(키보드, 마우스 등), 출력 장치(모니터, 프린터 등), 그리고 주변 기기 들로 이루어져 있다.
      
      구성 품목
      메모리
      컴퓨터 메모리(Computer Memory)는 읽을 수만 있는 롬과 읽고 쓸 수 있는 램으로 나뉜다. 롬에는 주로 컴퓨터가 가장 기본적인 작업을 수행할 수 있는 프로그램, 곧 펌웨어가 저장되어 있다. 컴퓨터 전원을 켜면, 컴퓨터는 롬에 저장된 프로그램에 따라서 명령을 수행한 뒤, 나머지 운영 체제에 관련된 프로그램을 다른 저장 매체에서 메인 메모리로 올려 놓은 다음 실행한다.
      
      또, 사용자가 프로그램을 수행할 때에도 운영 체제는 프로그램을 램에 올려서 명령을 수행하며, 옛 결과물을 잠깐 동안 램에 저장한다. 작업을 마치면 그 결과물을 오랫동안 보관하기 위해 다시 외부 메모리에 저장한다.
      
      중앙처리장치
      중앙 처리 장치(CPU; Central Processing Unit, MPU; Microprocessor Unit)는 메인보드 안에 상주하며 메인 메모리에서 읽어온 데이터를 처리한다. 컴퓨터의 핵심 부품이라고 할 수 있다.
      
      입출력 장치
      입출력 장치(I/O Device Input & Output Device)는 입력 장치와 출력 장치로 나뉜다. 키보드, 마우스, 스캐너와 같은 컴퓨터에 어떤 데이터를 입력하게 해주는 장치를 입력 장치라고 하며 프린터, 모니터와 같이 컴퓨터에서 처리한 결과를 화면이나 종이 같은 매체로 출력하는 장치를 출력 장치라고 한다.
      
      명령어/함수
      원래는 0과 1로 이루어진 기계어만 인식한다.
      그러나 사람들은 코볼이나 C++등 여러 가지 프로그래밍 언어들을 개발하여 기계어로 번역하는 프로그램의 개발에 성공했다.
      구조
      내부에는 CPU와 RAM, 그래픽카드, 사운드카드, 모뎀, HDD와 SSD, ODD 그리고 각종 부품이나 장치들을 삽입할 수 있는 슬롯이 내장된 메인보드, 쿨링 용 팬 등이 있다. 키보드와 마우스, 프린터, 모니터, 스피커가 시스템에 포함되며 바코드 인식기, OMR, OCR, MICR, 조이스틱, 헤드셋 등을 추가할 수 있다.
      
      운영 체제
      운영 체제(OS; Operating System)란 원래 컴퓨터에서 일반적으로 이루어지는 반복적인 혹은 필요한 작동을 사람 대신 자동으로 해주기 위해 개발되었으며 보통 일반 프로그램이 돌아가기 위한 제반적인 것을 제어하거나 서비스를 제공하기 위해 존재한다.
      
      주 목적은 주변기기와 프로그램 메모리, 그리고 사용자 권리를 제어하고, 파일을 관리하는 것 등이 기본이지만 기종에 따라 특별한 목적을 가진 프로그램을 같이 운영하기도 한다.
      
      따라서 컴퓨터나 기종에 따라서 운영 체제가 다르며, 서로 운영 체제끼리 호환되지 않는 것이 보통이지만, 점점 발전하여 일부 기능은 서로 호환도 되게끔 프로그램을 짜는 것이 추세이다(크로스 플랫폼).
      
      범용 운영 체제(윈도우, 유닉스, 리눅스 등)와 특별한 운영 체제(휴대 전화, MP3 플레이어 등의 전용 운영 체제 등)들이 있으며 요즘은 운영 체제에서 기본 서비스 밖에 별도의 프로그램 등을 따로 설치하여 그 영역에 대한 폭을 광범위하게 넓혀 나가고 있다.
      
      저장 매체
      컴퓨터 저장매체는 초기에는 우리가 흔히 아는 '비디오 테이프'에 저장을 했다. 하지만 점차 기술이 발전하며 HDD 하드디스크라는 저장 매체가 만들어지며 더 작은 크기에 더 많은 양의 정보를 담을 수 있게 되었다. 최근에는 SSD라는 플래시 메모리를 이용한 저장 매체도 나오고 있다. SSD는 현재 대중화되어, 하드디스크 보다 빠른 속도로 각광받고 있으며, 대표적으로 64GB, 128GB, 256GB, 512GB 모델이 있다. 그리고 최근들어 1TB 모델도 나오고 있는 추세이다.
      
      응용 분야
      초기의 디지털 컴퓨터는 군사용으로서 야포의 탄도계산을 위해 설계되었으며[3], 로켓, 미사일, 핵무기 등을 설계하는 데 쓰였다. 컴퓨터의 성능이 좋아질수록 단시간에 처리할 수 있는 정보의 양도 많아졌으며, 이로 인해 컴퓨터를 이용해 빠른 결과를 얻을 수 있는 분야 역시 넓어졌다.
      
      네트워크와 인터넷
      기원
      1970년대에 미국 전역의 연구소들에 있는 컴퓨터들이 통신 기술을 통해 연결되기 시작했다. 이 작업은 ARPA의 후원을 받아 이루어졌으며 이 네트워크의 이름을 아파넷(ARPANET)이라 명명하였다. 아파넷의 토대가 된 기술은 꾸준히 발전하고, 학술기관 바깥으로 퍼져 나가서 인터넷이라 알려지게 되었다. 존 게이지(John Gage)와 썬 마이크로시스템즈의 빌 조이(Bill Joy)는 이를 “네트워크가 곧 컴퓨터가 되었다”고 표현하였다. 인터넷을 비롯한 네트워크의 발달로 운영 체제와 응용 프로그램들이 개인용 컴퓨터 바깥의 주변기기와 같은 다른 자원에도 접근할 수 있도록 변화되었다. 초기에 이런 설비에 접근할 수 있는 사람들은 한정되어 있었으나, 1990년대에 전자우편과 월드 와이드 웹 등의 확산과 더불어 이더넷(Ethernet)과 ADSL 같은 값싸고 빠른 네트워킹 기술이 개발되어 컴퓨터 네트워킹은 여러 나라에서 일상화되었으며, 휴대통신 기술과 결합하여 유비쿼터스(Ubiquitous)라는 신조어를 만들기도 했다.
      
      보안과 해킹
      컴퓨터를 통해 제작된 콘텐츠나 컴퓨터를 이용한 콘텐츠를, 나쁜 뜻을 품은 제 3자가 해당 콘텐츠의 취약점을 찾아내어 자신의 이기적인 목적을 달성하는 것(원 저자의 의도하지 않은)을 크래킹이라고 하며 그것을 막는 행위를 보안이라고 한다. 크래킹의 예로, 네트워크의 보안 취약점을 공격하거나, 일부 전문가들의 단순한 자기 과시를 위한 바이러스의 유포 등 과거와는 달리, 현재에는 지워도 지워지지 않는 광고 팝업 창, 게임기의 정품 소프트웨어 인식 장치를 무력하게 하는 하드웨어, 키보드를 누를 때 생기는 전자파를 이용하여 해당 컴퓨터에 접속하지 않고도 바깥에서 암호를 알아내는 장치 등 소프트웨어적, 하드웨어적으로 넓은 범위로 확산되어 가고 있다.
      
      참고로 해킹 행위가 불법인가 아닌가에 대한 것은 나라마다 다르며, 2004년 1월 이탈리아의 법원에서 모드 칩이 플레이스테이션 개발사인 소니의 독점을 막고 플레이스테이션2의 활용성을 더욱 높이려는 장치라 정의하고 사용자의 모드 칩 장착은 합법이라고 규정한 바가 있다.
      
      엔터테인먼트
      영화, 게임 등에서 흥미를 위한 도구로 이용된다.
      
      디자인
      비누곽, 컵 등에서부터, 자동차, 비행기, 건축물에 이르기까지 실로 다양한 방면의 사물을 디자인하기 위해 이용된다.
      
      시뮬레이션
      컴퓨터 성능의 발전과 함께 컴퓨터 그래픽스 (C.G.) 기술의 발전은 눈으로 확인하기 힘든 상황들을 컴퓨터에서 가상으로 진행해 볼 수 있게 했다. 대표적인 시뮬레이션으로는 원자와 전자의 위상, 기상 변화, 은하 간 충돌 등이 있으며, 실제로 경험하기엔 너무 위험하거나, 발생 확률이 극히 작아 경험하기 힘든 상황들이 주로 시뮬레이션 대상이 된다.
      
      자연 과학 분야 중 원자, 전자, 쿼크 등으로 구성된 미립자계에서의 미립자간 충돌, 위상에 관한 연구에 주로 이용되었으며, 관측 시간 단위가 매우 큰 지질상태 변화를 적절한 시간 단위로 보여주거나, 항성, 은하, 블랙홀 등으로 구성된 우주 공간의 변화를 적절한 화면 크기로 보여주었다.
      
      예술
      컴퓨터 작곡
      음악을 작곡하는 데 기계를 사용하려는 발상은 최근에 생겨난 것은 아니다. 이미 17세기 런던에 살던 사무엘 피프스란 사람이 만든 작곡 기계가 지금도 케임브리지 대학에 남아 있다. 어쨌든 명령받은 대로 일을 하는 것은 컴퓨터에게 아주 쉬운 일이며, 작곡에 관한 원칙을 짜넣은 프로그램이 개발되어 있다. 또 프로그램의 일부를 바꿔 줌으로써, 그 때마다 다른 작품을 만들어 낼 수도 있다.
      
      1955년에 처음으로 음악 작곡에 컴퓨터가 이용되었는데, 컴퓨터가 작곡한 음악은 인간이 작곡한 음악만큼 인기가 없었다. 그것은 아마 컴퓨터가 인간의 예술적 재능을 흉내낼 수 없기 때문이거나, 아니면 좋은 음악을 작곡시킬 만큼 세련된 프로그램이 아직 개발되지 않았기 때문일 것이다. 하지만 최근에는 컴퓨터를 이용한 작곡이 급증하고 있고, 새로운 기법을 도입한 신세대 음악가들에 의해 다양한 모습이 선보이고 있다.
      
      신시사이저
      신시사이저는 연주용 키보드와 컴퓨터를 조합한 복잡한 전자 장치이다. 악음(樂音)은 3개의 서로 다른 상(相)으로 구성되어 있는데, 기음상(起音相)에서는 소리가 점점 강해지며, 그 뒤 얼마 동안 거의 일정한 상태로 머물다가 소음상(消音相)에서는 점점 작아져 간다. 이 3가지 상을 어떻게 거쳐가느냐 하는 것은 악기에 따라 각각 특징이 있으며, 이 점이 각각의 악기에 독자적인 음색을 주는 것이다. 신시사이저는 각각의 상을 개별적으로 조정하여, 여러 가지 악기와 닮은 소리를 만들어 낼 수 있다. 연주는 키보드를 통해 이루어지며, 컴퓨터가 만들어 내는 음악은 마치 연주자가 선택한 악기에서 울려오는 듯이 들린다.
      
      컴퓨터와 상업미술
      예술이란 풍부한 상상력과 높은 기교에 의해서 새롭고 매력적인 것을 만들어 내는 과정이라고 할 수 있다. 현재 상업미술의 많은 분야에서는 컴퓨터의 도움을 받아 작품이 만들어지고 있다. 예를 들면 그래픽 디자이너는 작품의 안을 짤 때 컴퓨터를 이용하여 화면상에 러프 스케치를 그리고 색을 칠하고 선이나 문장을 자유로이 바꿀 수가 있다. 디자이너는 작업하는 동안 여러 가지 요소를 변화시켜, 필요하다면 그림 자체도 얼마든지 변경시켜 나간다. 만족스러운 것이 완성되었을 때, 혹은 작성 도중이라도 화면상의 작품을 인쇄할 수가 있다. 이 경우 별도의 프로그램에 의해, 화상을 이루고 있는 수치의 정보를 컬러 작도기(作圖器)를 움직이는 데 필요한 지령으로 변환시킨다. 옷감 디자이너도 이와 마찬가지 방법을 사용하여, 실제로 옷감을 짜지 않고도 어떠한 무늬의 옷감이 될 것인가를 수요자에게 보여 줄 수 있다. 수요자가 그 무늬에 만족하면, 컴퓨터는 방직기를 작동시키는 데 필요한 일련의 명령을 하고 자동적으로 그 무늬의 옷감을 짜낸다.
      
      컴퓨터와 설계 디자인
      기술자는 상상력을 구사하여 목표했던 기능을 발휘하는, 새롭고 매력 있는 장치나 기계를 만들어 내기 위해 계산, 대체안의 검토, 해(解)의 분석과 제시 등을 필요로 한다. 컴퓨터 원용 설계(CAD)는 이러한 작업의 모든 측면에서 기술자를 돕는다. CAD 프로그램은 흔히 마우스를 써서 설계 내용을 컴퓨터에 입력한다. 프로그램은 설계자의 명령을 숫자로 변환하고 처리하여, 화면에 그 물건의 형태를 나타낸다. 물론 3차원의 입체적 화상으로서 표시하는 프로그램도 개발되어 있다. 이 화상은 원하는 대로 그 모양이나 기능에 의해서 명확한 이미지를 얻을 수 있다. 이 부분에서 목표에 이르면, 다음에는 실제로 제작하기 위한 상세한 도면과 부품목록을 만들게 된다. 여기에는 2차원의 프로그램을 쓰며, 데이터는 3차원 프로그램으로부터 입력하든가 설계자가 직접 입력한다. 많은 사업에서 제도판은 컴퓨터 원용 프로그램과 데스크톱 컴퓨터로 인해 완전히 밀려나고 말았다. 화면상에서 도면이 완성되면 다른 프로그램을 사용하여, 도면의 수치에 의한 표현을 프린터를 작동시키기 위한 지령으로 변환한다. 부품을 해석하고, 그 기능을 에측하기 위해서는 별도의 프로그램을 사용하는데, 구조물에 하중이 가해졌을 때의 변화를 계산하는 것 등이 그 예이다. 또 부품 내부의 열이나 전류의 흐름을 그림으로 나타내거나, 부품을 만드는 데 필요한 비용을 계산하는 프로그램도 있다. 여러 가지 CAD 시스템을 제조 기계와 결합시켜, 설계에서 제조까지 일관된 공정을 형성할 수도 있다. 이 방식을 도입하는 데는 높은 비용과 복잡한 과정이 필요하기 때문에 별로 채택되지 않지만, 기업으로서 성공하기 위해 이 방식이 필요한 산업도 있다. 그 좋은 예가 자동차 산업이다. 디자이너가 아이디어를 스케치하면 그로부터 상세한 도면이 만들어진다. 컴퓨터에서는 이미 사용되고 있는 부품·제조·가공·기계에 대한 지식을 이용하여 그 제품을 만드는 데 필요한 작업 프로그램을 만든다. 각각의 부품을 만드는 제조·가공 기계의 준비가 완료되면, 필요한 일련의 명령이 기계에 직접 전달된다. 그리고 모든 부품이 갖추어지면, 컴퓨터는 그 사실을 기술자에게 알리고 기술자는 조립 작업을 개시한다. 예전 같으면 완벽한 시제품이 만들어질 때까지 몇 번이고 시제품을 만들어 보고, 마음에 들지 않으면 깨뜨려 버리는 작업을 되풀이했다. 그러나 컴퓨터 원용 기술을 이용하면, 시제품의 수를 줄이고 제품 개발 비용을 낮출 수가 있다.
      
      컴퓨터 그래픽스
      컴퓨터를 사용하면 실험을 통해 얻어진 측정치를 그림의 형태로 바꾸어 표시할 수가 있다. 이렇게 그림으로 나타내는 것이 길다란 수치의 나열보다 훨씬 이해하기 쉬운데, 이것도 컴퓨터 그래픽스의 하나이다. 예를 들면, 각 지방의 강우량이나 환자의 몸 각 부분을 통과한 X선의 강도 등이 하나의 지도로 표시된다. 컴퓨터 그래픽스를 이용하여 측정치를 표시할 경우, 같은 값은 같은 색으로 나타나며, 색깔로서 값의 차이를 표현하고 있다. 이와 같이 측정값을 여러 색의 화상으로 표현함으로써, 실제로는 눈에 보이지 않은 대상에 대해, 경우에 따라서는 그 움직임에까지 직관적인 이미지를 줄 수가 있다.
      
      인공위성과 컴퓨터 그래픽스
      컴퓨터 그래픽스는 '랜드새트'와 같은 원격탐사 위성에서 촬영하여 보내온 지구의 모습을 나타내는 데도 이용된다. 이 인공위성은 여러 가지 파장의 빛을 사용하여 지구를 탐사하고, 지구로부터의 반사광의 강도를 전자적으로 기록하여 신호로써 보내오는데, 컴퓨터는 이 신호를 처리하여 채색 화상을 만든다. 보통의 사진에서는 촬영할 수 없는 것을 화상으로 만들 때에도 컴퓨터 그래픽스를 사용할 수가 있다. 예를 들면, 항성으로부터 오는 보이지 않는 전파의 강도를 측정하여 그 결과를 나타내거나, 레이다에 의한 비행기의 탐지, 일기 개황도 화면에 표시할 수 있다. 또한 수중 탐사의 음파 분석에도 컴퓨터를 사용한다. 물 위에 떠 있는 배로부터 아래를 향해 내보낸 음파의 반향의 강도를 측정하고, 그 결과를 해저지도로 표시한다. 이 방법으로 침몰한 배를 발견할 수도 있는데, 실제로 침몰한 타이타닉호를 발견하는 데에도 활용되었다.
      
      의학에서의 응용
      병원에서는 환자 몸의 내부 영상을 얻기 위해 컴퓨터에 의한 화상 기술을 폭넓게 이용하고 있다. 어머니 태내에 있는 태아의 화상도 초음파와 컴퓨터를 이용하여 얻어진다. 의사는 그로써 태아가 정상으로 자라고 있는가를 진단할 수 있다. 인체에 함유되어 있는 화학 물질은 전자파를 이용한 핵자기공명 영상법(核磁氣共鳴映像法：NMRI)을 써서 조사할 수가 있다. 환자는 긴 원통 모양의 자석 속에 눕는다. 자장 속에서 원하는 각각 특정 주파수의 전자파를 흡수하므로, 몸 안에 있는 각각의 원자의 농도를 측정할 수가 있으며, 그 데이터를 컴퓨터를 이용하여 화상으로 만들어 내고 있는 것이다. 또 하나의 효과적인 영상법은 CT스캐너이다. CT스캐너는 X선원으로부터 방사상으로 발사한 X선을 환자 몸 안에 통과시킨 뒤 측정한다. X선원을 회전시킴으로써 인체의 단면을 여러 각도에서 볼 수가 있으며, 컴퓨터는 이것을 통해 완전한 화상을 만들어 낸다.
      
      텔레비전 방송
      텔레비전 방송에서도 컴퓨터는 중요한 역할을 맡고 있다. 최근의 텔레비전 방송에서 많이 볼 수 있는 것으로 컴퓨터 그래픽이 있다. 컴퓨터 그래픽은 여러 가지 수치 자료를 그림과 도표를 바꾸어 표시하는 것으로, 점·선·원·타원·문자 등을 표시하며 그림과 도표, 문자 등을 크게 확대, 축소할 수 있다. 또한 위치를 움직이거나 회전시킬 수 있다. 그리고 다른 화면과 겹쳐서 문자, 그림, 도표 등을 나타낼 수 있고, 물체의 입체적인 모습으로 나타낼 수 있다. 또한 글자, 그림, 도표 등의 색깔을 자유롭게 변환시킬 수 있다. 컴퓨터 그래픽은 이 밖에도 여러 가지 기능이 있어 시청자에게 보다 재미있고 알기 쉬운 그림과 도표를 보여주고 있다.
      
      컴퓨터 직종과 학문분야
      현대 사회에서 많은 직업군이 컴퓨터를 사용한다. 컴퓨터에 대한 연구, 프로그래밍, 활용 기술을 전문으로 하는 직종과 학과는 꾸준히 발전해왔다. 각 직종에 대한 전문 용어들은 계속 바뀌고 새로운 분야가 생겨나고 있다. 주요한 학문 분야는 다음과 같다:
      
      컴퓨터 과학은 효율적인 알고리즘을 개발하는 등, 연산에 관련된 과정을 연구하는 학문이다. 전산학은 컴퓨터를 사용함으로써 문제들을 해결할 수 있는지, 어떻게 효과적으로 문제를 풀 수 있는지에 대한 답을 찾는다. 새로운 컴퓨터를 어떻게 디자인할까 연구하기도 한다.
      소프트웨어 공학은 믿을 수 있는 소프트웨어 시스템을 개발하며, 개발에 드는 시간과 비용을 계산하고 줄이는 방법을 연구하여 실행한다.
      정보 시스템은 사업체를 비롯한 다양한 조직 환경에서 컴퓨터 시스템 활용에 초점을 맞춘다.
      다른 분야와 컴퓨터를 잇는 학문 분야가 많이 생겨나고 있다. 한 가지 예로 컴퓨터 기술을 응용해 지리 정보에 관한 문제를 처리하는 지리정보시스템 전문가를 들 수 있다.
      컴퓨터의 부품
      본체
      메인보드
      칩셋(노스브릿지 - (사우스 브릿지나 CPU에 통합됨), 사우스브릿지)
      바이오스 플래시칩
      CPU(중앙처리장치)
      RAM
      그래픽카드
      사운드카드(대부분 메인보드에 내장)
      전원 공급장치
      쿨러
      하드디스크
      ODD(선택사항)
      TV 수신카드(선택사양)
      외부기기
      모니터
      마우스
      키보드
      프린터
      스캐너
      공유기, 모뎀
      LAN
      USB
      플래시 메모리
      외장형 TV 수신카드(선택사양, 대부분 USB)
      보존 및 소장
      컴퓨터는 되게 오래 사용하지는 않는다. 컴퓨터는 역사적인 가치나 공을 들인 컴퓨터 등이 보존되고 또한 보기 힘든 아날로그 방식의 컴퓨터가 자주 보존된다. 대한민국에서는 대부분 금성사(현 LG전자)의 패미콤 마이티 아니면 삼성전자의 SPC-1000등 구형 아날로그 컴퓨터 등이 보존처리되고 소장자도 기업역사관 아니면 박물관 등이 해당된다.
      
      같이 보기
      휴대폰
      인터넷
      정보화 사회
      PC
      PC 게임
      멀티태스킹
      프로그래밍 언어
      슈퍼컴퓨터
      마이크로프로세서
      노트북
      컴퓨터 과학
      컴퓨터 바이러스
      컴퓨터 클러스터
      컴퓨터 지원 설계
      컴퓨터 보안
      컴퓨터의 역사
      컴퓨터 네트워크
      컴퓨터 프로그래밍
      컴퓨터 모니터
      컴퓨터 포렌식
      컴퓨터 활용능력
      컴퓨터 과학자 목록
      컴퓨터 글꼴
      컴퓨터 구조
      `,
    },
    {
      id: 10,
      title: "전자기학",
      contents: `전자기학(電磁氣學, 영어: Electromagnetism)은 전기와 자기 현상을 탐구하는 학문이다. 전기와 자기는 전자기장을 이룬다. 자기 현상은 이미 기원전 2000년 무렵 중국 문헌에 등장하며, 전기 역시 기원전 700년 무렵 고대 그리스 세계에 알려져 있었다. 그러나, 전기와 자기가 전자기력이라는 동일한 기본 상호작용에 의한 현상이라는 점은 19세기에 와서야 밝혀졌다.[1]:533

      전기장
      
      플라스틱 미끄럼틀을 타고 노는 아이가 정전기에 대전되어 머리카락이 곤두서 있다.
      
      양전하와 음전하로 대전된 물체가 만들어 내는 전기장의 모습
      <nowiki /> 이 부분의 본문은 전기장입니다.
      양털로 만든 옷감에 플라스틱 빗을 여러 번 문지른 후 머리카락에 갖다 대면 머리카락이 빗에 달라 붙는 것을 볼 수 있다. 이와 같이 물체가 전기를 띄게 되는 것을 대전되었다고 한다. 고대 그리스 시대의 철학자 탈레스는 호박(琥珀)을 마찰하면 호박에 작은 물체가 달라 붙는 것을 관찰하였다.[2] 전기를 뜻하는 영어: electricity는 호박을 뜻하는 그리스어: ἤλεκτρον에서 온 것으로 추정된다.[3]
      
      위에 든 예와 같이 두 물체를 마찰하여 대전된 전기를 정전기라고 하는데, 정전기가 대전되는 까닭은 물체를 이루는 원자가 지니는 전자 가운데 일부가 적은 에너지로도 쉽게 원자에서 벗어날 수 있기 때문이다. 이렇게 원자로부터 벗어나 움직이는 전자를 자유 전자라고 한다.[주해 1] 금속과 같이 자유 전자를 많이 지닌 물질은 언제나 전자들이 쉽게 이동하기 때문에 대전되었더라도 다른 물체와 닿게 되면 전기가 쉽게 전달되어 버린다. 이런 물체를 도체라고 한다. 반면에 고무나 유리와 같은 물질은 자유전자가 매우 적어서 한 번 대전되면 전하를 비교적 오랫동안 유지하게 된다. 이런 물체를 부도체라고 한다. 물질 가운데에는 상태에 따라 도체와 부도체의 성질을 모두 가질 수 있는 것도 있다. 이런 물질들은 반도체라고 부른다. 반도체는 최근 여러 전자 제품에 널리 사용되고 있다.[4]
      
      전기에는 서로 다른 두 종류의 전하가 있어서 같은 것은 밀쳐내고 다른 것과는 끌어당긴다. 18세기 미국의 과학자이자 정치가였던 벤저민 프랭클린은 두 전하를 한 쪽은 양 전하, 다른 쪽은 음 전하라고 이름 붙였다.[1]:536 이런 척력과 인력의 크기는 물체가 갖고 있는 전하의 양과 두 물체 사이의 거리에 관계된다. 이렇게 정전기로 대전된 두 물체 사이에 작용하는 힘은 쿨롱의 법칙으로 계산될 수 있다.[5]:65-68
      
      어떤 공간에 대전된 한 개의 물체가 있다고 할 때, 이 물체 근처로 지나가는 다른 대전된 물체는 쿨롱의 법칙에 따라 서로의 거리가 가까워 질 수록 더 강한 힘을 받게 된다. 반대로 일정 거리 이상 멀어지면 두 전하 사이의 힘은 무시될 수 있을 정도로 작아질 것이다. 이렇게 하나의 전하에서 만들어지는 전기력이 영향을 미치는 범위를 전기장이라고 한다. 전기장의 세기는 어떤 위치에 있는 물체가 단위 전하당 얼마만큼의 힘을 받는지로 계산한다. 국제단위계로 나타내면 쿨롱당 뉴턴, 즉 
      �
      /
      �
      N / C로 나타낸다.[6]
      
      물체에 고여있는 정전기와 달리 전류는 양전하에서 음전하로 흐르는 전기의 흐름이다. 1800년 이탈리아의 과학자 알레산드로 볼타는 황산 수용액에 구리막대와 아연막대를 담은 후, 두 막대를 금속선으로 이어 전지를 발명하였다. 볼타 전지는 최초로 전류를 지속적으로 공급하는 장치였다.[7]:45–47
      
      자기장
      
      18세기에 제작된 항해용 나침반
      
      막대 자석 주위에 자기장을 따라 늘어선 철가루
      <nowiki /> 이 부분의 본문은 자기장입니다.
      고대 중국에서는 자석에 철이달라붙는 다는 사실과 자석이 남북을 가리킨다는 사실을 알고 있었다. 고대 중국인들은 이러한 성질을 이용하여 나침반을 만들어 사용하였다. 나침반은 세계 여러 곳에 전파되어 항해에 필수적인 장비가 되었다.[5]:102
      
      자석은 전하와 같이 같은 극끼리는 밀치고 다른 극끼리는 잡아당기는 힘이 작용한다. 관례적으로 자석에서 북극을 가리키는 쪽을 N극, 반대편을 S극이라고 한다. 물질이 자기를 띄게 되는 것은 원자가 스스로 전류 고리를 갖기 때문이다. 원자핵의 자전과 원자핵 주변을 돌고 있는 전자의 공전과 자전때문에 원자에 전류 고리가 생기고 이 때문에 원자 자체에 N극과 S극의 성질을 나타내는 자기쌍극자가 형성된다.[8] 전기의 기본 단위인 전하가 음전하 또는 양전하 홀로 존재할 수 있는 것과는 다르게 자기는 자기쌍극자에 의해 발생하는 현상이기 때문에, 기초 단위에서부터 N극과 S극이 동시에 존재한다.[1]:680
      
      자석에 철과 같은 물질이 달라붙는 현상을 자기라고 하고, 자석에 달라붙는 물질을 자성체라고 한다. 널리 알려진 자성체로는 철 이외에 니켈과 같은 것이 있다. 자기에 반응하지 않는 물질은 비자성체라고 하며, 이 외에 자석에 아주 약하게 반응하는 알루미늄, 크롬과 같은 물질은 상자성체, 구리, 금, 은과 같이 자석이 가까이 가면 약하게 반발하는 물질은 반자성체라고 한다.[5]:137
      
      대부분의 물질은 원자단위의 자기쌍극자가 무질서하게 놓여져 있기 때문에 서로간의 자기가 상충되어 자성을 띄지 않지만, 철이나 니켈같은 물질들은 원자의 배열이 자기가 한 쪽 방향으로 정렬되기 쉽도록 되어 있어서 쉽게 자성을 띄게 되고 한 번 자석이 되면 계속하여 자성을 유지하게 된다. 자성을 잃지 않고 계속 지니는 자석을 영구 자석이라고 한다.[9] 철 막대를 자석의 한 극으로 내려 치면 철 원자의 자기쌍극자가 한 쪽으로 정렬되어 영구 자석이 된다. 한편, 영구 자석이 된 철이라고 하더라도 약 770℃ 가 되면 자성을 잃는데, 열에 의해 원자가 무질서하게 운동하기 때문이다.[10]
      
      전기장과 마찬가지로 자기가 미치는 공간을 자기장이라고 한다. 위에 설명한 바와 같이 자기의 단위 자극인 자하는 전하와 달리 홀로 존재하지 않고 언제나 쌍극자로 존재하므로 N극에서 나와 S극까지 이어지는 하나의 자기 흐름을 생각할 수 있다. 이렇게 하나의 폐곡선으로 연결되는 자기 흐름을 자기력선이라고 하는데, 자기장은 일정 공간에 자기력선이 얼마나 많이 모여있는지와 그렇게 모인 자기력선이 얼마나 센 지를 고려하여야 한다. 자기력선이 일정 공간에 얼마나 많이 모여 있는지는 자기 선속 밀도(磁氣線束密度)라고 하며, 관례적으로 
      �
      →\overrightarrow B로 나타낸다. 한편, 특정 위치에서 자기장의 세기는 
      �
      →\overrightarrow H로 나타내는데, 그곳에 놓인 자하가 받는 힘을 뜻한다.[주해 2][11] 국제단위계에서는 자기장의 단위로 테슬라(T)를 사용하지만 일반적으로는 가우스(G)가 더 많이 쓰인다.[1]:683
      
      자기장의 경우에 자기 선속 밀도와 자기장의 세기가 다른 까닭은 자기장이 통과하는 매질마다 자기장을 전달하는 비율이 다르기 때문이다. 어떤 물질이 자화되어 자기장을 전달하는 비율을 투자율(透磁率)이라고 하고 그리스 문자 μ로 나타낸다. 투자율은 물질마다 고유의 값이 있는데 투자율이 수백에 근접하는 강자성 물체를 제외하면 대부분의 물질은 1에 가까운 투자율을 가지고 있다.[12]:39[주해 3] 진공 또는 자유공간의 투자율은 특히 μ 0로 나타내며, 그 값은 
      4
      �
      ×
      10
      −
      7
      �
      /
      �
      4 \pi \times 10^{-7} A / m이다. 자기장의 자기 선속 밀도 
      �
      →\overrightarrow B는 자기장의 세기
      �
      →\overrightarrow H에 투자율 μ를 곱한 것과 같은 값을 갖는다. 즉, 다음과 같은 수식으로 나타낼 수 있다.[12]:39
      
      �
      →
      =
      �
      �
      →\overrightarrow B = \mu \overrightarrow H
      전자기 유도
      
      1823년 제작된 스터전의 전자석
      <nowiki /> 이 부분의 본문은 전자기 유도입니다.
      전기와 자기는 아주 오래전부터 알려진 현상이었지만, 이 둘이 사실은 같은 상호 작용이란 것은 19세기에 와서야 밝혀졌다. 1820년 덴마크의 과학자 한스 크리스티안 외르스테드는 전류가 흐르는 도선 가까이 나침반을 두면 나침반의 바늘이 가리키는 방향이 변하는 것을 관찰하고 전류와 자기 사이에 연관이 있음을 밝혀냈다.[13] 프랑스의 과학자 앙드레마리 앙페르는 외르스테드의 논문을 읽고 자신도 같은 실험을 하여 전류가 흐르는 도선에 생기는 자기장의 방향을 관찰하였다. 앙페르는 전류가 오른손의 엄지손가락 방향으로 흐를 때 자기장은 나머지 네 손가락을 말아쥔 방향으로 형성된다는 것을 밝혔는데, 오른손 엄지를 위로 치켜 든다면 나머지 말아 쥔 네손가락은 반시계방향을 나타내게 된다. 이러한 발견은 앙페르의 오른나사 법칙이라는 이름으로 널리 알려지게 되었고, 훗날 수리 모형이 만들어져 앙페르의 회로 법칙이 수립되었다.[14] 1824년 영국의 과학자 윌리엄 스터전은 전류에서 발생하는 자기장을 이용하여 전자석을 만들었다. 스터전이 처음 만든 전자석은 말굽 모양의 철심을 자기 코어로 이용한 것이었다. 스터전은 자기 코어에 굵은 구리 전선을 18 번 감아 전자석을 만들었다. 당시에는 오늘날과 같은 절연체가 없었기 때문에 스터전은 구리 도선에 바니시를 발라 절연체로 사용하였다.[15][16]
      
      
      패러데이의 전자기 유도 실험. 코일을 감아 만든 전자석을 다른 코일 속에 넣고 움직이면 전류가 발생한다.
      전류가 자기장을 만든다는 사실이 알려지자, 자기장에서도 전류를 만들 수 있지 않을까 하는 의문을 갖는 것은 어찌보면 당연한 것이었다. 1831년 마이클 패러데이는 자석을 도선 가까이에서 움직이면 전류가 생긴다는 것을 밝혀내었다. 패러데이는 영구 자석이든, 전자석이든 자기장을 형성하는 것이기만 하면 도선가까이에서 움직이면(즉, 자기장의 변화가 일어나면) 전류가 생긴다는 것을 알아내고 이를 정리하여 패러데이 전자기 유도 법칙을 발표하였다.[17] 자기에서 전기가 유도될 수 있다는 것이 알려지자, 이것을 이용한 많은 기술들이 발명되었다. 니콜라 테슬라는 전자기 유도를 이용하여 교류 발전기를 발명하였다.[18]
      
      맥스웰 방정식
      
      제임스 클러크 맥스웰
      
      1901년 대서양 너머로 무선 신호를 보내고 있는 굴리엘모 마르코니
      <nowiki /> 이 부분의 본문은 맥스웰 방정식입니다.
      1864년 제임스 클러크 맥스웰은 기존의 전기와 자기에 대한 이론의 수리 모형들을 약 20개의 방정식으로 정리하였다. 맥스웰은 나중에 의미가 같은 방정식들은 과감히 생략하고 본질적인 네 개의 방정식으로 정리하였다. 이를 맥스웰 방정식이라고 한다.[7]:112
      
      맥스웰 방정식이 다루는 전자기학의 법칙은 다음과 같다.[주해 4]
      
      가우스 법칙: 가우스의 법칙은 전하에 의해 만들어지는 전기장의 에너지를 나타낸다. 이는 본질적으로 쿨롱의 법칙과 같은 결과를 나타내게 된다. 그러나, 가우스의 법칙은 두 개의 전하에 작용하는 힘을 계산하는 쿨롱의 법칙과 달리 하나의 전하만을 고려할 때에도 그에 따른 전하량을 계산할 수 있다.
      가우스 자기 법칙: 자기는 언제나 N극과 S극이 동시에 존재하므로, 닫힌 곡면을 지나는 자기량은 곡면안으로 들어가는 것과 통과하여 나오는 것이 언제나 같게 된다. 자기력은 벡터이기 때문에 들어가는 자기량과 나오는 자기력의 합은 언제나 0 이 된다.
      패러데이 전자기 유도 법칙 : 도선 주변에서 자기장이 변화하면 전류가 생기는데, 이렇게 전류가 발생하도록 하는 힘을 기전력이라고 한다.패러데이의 전자기 유도 법칙은 자기 선속 밀도의 변화와 기전력의 관례를 수리적으로 정리한 법칙이다.
      앙페르 회로 법칙 : 앙페르는 전류 주변에 흐르는 자기장의 세기를 예측할 수 있는 수리 모형을 만들었다. 하지만, 앙페르가 만든 방정식은 불완전한 면이 있었기 때문에 맥스웰은 이를 개선하여 새로운 방정식으로 대체하였다. 이 때문에 수정된 앙페르 회로 법칙은 앙페르-맥스웰 회로 법칙이라고 불리기도 한다.
      맥스웰은 전자기학에 대한 법칙들의 수리 모형을 정리하면서 로런츠 힘은 다루지 않았다. 로렌츠 힘은 전하를 띈 물체가 전기장 안에서 받는 힘을 뜻한다. 오늘날 전자기학은 맥스웰 방정식과 로런츠 힘을 기반으로 하고 있다.[7]:114–115
      
      맥스웰은 맥스웰 방정식을 정리한 후, 자계가 사인파와 같은 파동을 보이며 변화한다면 전계 역시 그에 따라 사인파 파동을 만들어 내게 될 것이고, 그 반대도 마찬가지 일 것이므로, 전기와 자기의 성질을 모두 갖는 파동, 즉 전자파가 존재할 것이라고 예측하였다. 맥스웰이 예측한 전자파는 1888년 하인리히 루돌프 헤르츠의 실험을 통해 증명되었다. 이후, 전기 회로에서 생성된 전자파를 안테나를 통해 방출하거나 수신할 수 있다는 것이 알려지게 되었고, 이를 이용하여 무선 통신이나 방송과 같은 전자파를 이용한 기술들이 발명되었다.[7]:175-182
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      전자기학
      전기
      자기
      전자기역학
      고전 전자기학
      양자 전기역학
      이중 슬릿 실험
      전자석
      엑스선
      광학
      물리학`,
    },
    {
      id: 11,
      title: "마이크로프로세서",
      contents: `마이크로프로세서(영어: microprocessor, microprocessing unit) 또는 초소형 연산 처리 장치(超小型演算處理裝置)는 컴퓨터의 중앙 처리 장치(CPU)를 말한다. 기계어 코드를 실행하기 위해 실행과정을 단계별로 나누어 처리를 위한 마이크로 코드를 작성하고, 이 마이크로 코드에 의해 단계적으로 처리하는 논리회로를 말한다.[1] 초기의 마이크로프로세서는 하나의 칩으로 만들어졌으나, 점점 다른 하드웨어 요소들을 집적시키는 경향이 있다. 따라서 CPU-코어라는 말로 다른 요소들과 구별한다.중앙 처리 장치(CPU)가 컴퓨터 전체 시스템의 위치와 입장에서 나온 말이라면, 마이크로프로세서는 동작 방식에서 나온 말로 서로 같은 것이다.

      마이크로프로세서 개발자는 기계어 설계를 하고, 기계어를 수행하기 위해 마이크로코드를 작성한다. 기계어를 분류하여 공통점을 찾아내어 한개의 기계어 코드가 실행되는 과정을 단계별로 기능적 블럭으로 나눈다. 마치 C언어의 함수처럼 기능별로 작성 한다. 이것을 디지털회로와 결합하여 동작을 하게 된다. 마이크로코드는 마이크로프로세서 내의 마스크 롬에 저장되고 사용자는 변경할 수 없다. 마스크 ROM마이크로코드 변경이라는 것은 곧 기계어 코드 변경을 의미하기 때문이다. ROM에 저장 된 정해진 코드는 마이크로프로세서의 입장에서는 부담이 될 수 있다. 고 기능이라면 크게 신경 쓸 일은 아니지 저속, 저전력 등에서는 신경 쓸 일이다. 따라서 마이크로코드 자체를 논리회로로 대처하는 경우도 있다. NMOS 6502 영어: (MOS Technology 6502)나 일부의 RISC 마이크로프로세서는 PLA와 순차 논리회로(하드웨어 방식)로 대체 한다.[2]
      
      마이크로프로세서는 컴퓨터의 CPU의 기능을 한 개 또는 몇 개 이내의 집적회로에 집약한다.[1] 마이크로프로세서는 디지털 데이터를 입력받고, 메모리에 저장된 지시에 따라 그것을 처리하고, 결과를 출력으로 내놓는 다목적의 프로그램 가능한 기기이다. 내장메모리가 있다는 점에서 순차 논리의 예이다. 마이크로프로세서는 2진수로 대표되는 숫자와 기호를 바탕으로 작동한다.
      
      한 개 또는 소수의 칩에 전체 CPU를 집적하는 것은 처리 전력의 비용을 상당히 줄였다. 집적회로 프로세서는 고도로 자동화된 과정에 따라 대량생산되기 때문에, 생산 비용이 적다. 단일 칩 프로세서는 오류가 발생할 가능성이 있는 전기 배선의 수가 매우 적기 때문에, 신뢰성이 올라간다.
      
      마이크로프로세서 이전의 작은 컴퓨터들은 중간 규모나 소규모 집적회로의 기판에 납땜을 이용해서 주로 만들어졌다. 마이크로프로세서는 이것을 한 개나 소수의 대규모 집적회로에 집적시켰다. 마이크로프로세서의 계속된 용량의 증가는 다른 종류의 컴퓨터들을 거의 구식으로 만들어버렸고, 현재는 가장 작은 임베디드 시스템이나 휴대용 기기에서부터 가장 큰 메인프레임이나 슈퍼컴퓨터에까지 쓰이고 있다.
      
      역사
      "마이크로프로세서"라는 용어를 처음 사용한 것은 1968년 발표된 시스템 21 소형 컴퓨터 시스템에 쓰인 맞춤식 집적 회로를 설명한 비아트론 컴퓨터 시스템즈이다.
      
      1971년에 인텔은 레슬리 배다스의 감독 하에 최초의 4비트 마이크로프로세서 4004를(인텔 4004), 1972년에 8비트 마이크로프로세서 8008을 선보였다. 최초의 마이크로프로세서는 일반 컴퓨터의 중앙처리장치에서 주기억장치를 제외한 연산장치, 제어장치 및 각종 레지스터들을 단지 1개의 IC 소자에 집적시킨 것이다.
      
      오늘날은 이를 흔히 MPU(microprocessing unit)라고 부르기도 한다.
      
      개요
      용도에 따라 입·출력 등의 주변 회로나 메모리를 내장한 것도 있어서 하나의 LSI 또는 컴퓨터 시스템으로서 동작하는 것을 ‘원칩 마이크로컴퓨터’라고 부른다. 마이크로프로세서는 하나의 LSI칩으로 기능을 수행할 수도 있지만 여러 개의 LSI로 구성된 것도 존재한다.
      
      마이크로프로세서가 개발되기 이전까지 CPU는 진공관이나 트랜지스터와 같은 단독 소자로 구성되거나 집적회로가 개발되고 나서도 많은 집적회로의 편성으로서 구성되어 왔었다. 집적회로의 규모가 커지고 많은 회로를 삽입할 수 있는 기술이 등장해 하나의 대규모 집적회로에 CPU 기능을 수행할 수 있게 되었다. 이에 따라 생산과 이용이 편리하게 되고 대량 소비가 가능해짐에 따라 성능은 증가하고 가격도 점차 떨어져 갔다.
      
      인텔의 고든 무어가 1965년에 약 18개월마다 2배가 된다고 하는 ‘무어의 법칙’을 내놓은 뒤 오늘에 이르기까지 이 법칙에 따라 마이크로프로세서의 성능은 계속 향상되고 있다. 현재 마이크로프로세서는 슈퍼 컴퓨터부터 소형 노트북 컴퓨터까지 다양한 종류의 컴퓨터에 탑재되고 있다.
      
      마이크로프로세서의 구성
      마이크로프로세서는 제어장치(명령어 해석 및 실행), 레지스터, ALU등의 기본 구성을 갖는다.
      
      제어장치(명령어 해석 및 실행) : 마이크로코드의 실행에 의해 메모리의 기계어 코드를 읽고, 어떤 기능인지를 결정한 다음 해당 기능을 실행한다.
      레지스터
      범용 레지스터 : 데이터 처리를 위해 데이터를 저장한다.
      특수 레지스터 : 특수 기능을 위해 설정된 레지스터이다. 레지스터의 기능이 결정되어 있다.
      SP (Stack Pointer) : 스택 구조를 위한 포인터이다. 보통 push에 의해 데이터가 저장될 때, 메모리의 주소가 감소하는 것이 일반적이다. 8051은 반대로 증가한다. PUSH, POP 등의 스택 명령어와 CALL/RET에 의한 복귀주소가 저장된다. 액세스단위는 8비트 마이크로프로세서는 8비트 단위로 32비트 CPU에서 32비트 단위가 기본 단위이다.
      PC (Program Counter) 또는 IP(Instruction Pointer) : 실행해야 하는 기계어 명령어가 존재하는 메모리 주소값을 저장한다. 따라서 이 레지스트의 값에 의해 기계어 명령어가 패치되어 읽혀 명령어 해석되어 실행된다.
      인덱스 레지스터 : 데이터를 처리할 주소값을 저장한다. 이 레지스터 값을 데이터 액세스할 때 주소값으로 활용한다. 데이터 포인터를 저장하는 레지스터이다.
      FLAG, 인터럽트 제어, 상태 저장, CPU 제어, 기타를 저장하는 레지스터.
      정수형 산술 논리 장치(ALU) : 수학연산, 논리연산, 쉬프트 등의 수학적 연산을 담당한다.
      사칙연산 : 더하기, 빼기, 나누기, 곱하기를 한다. 정수형 ALU가 대부분이고, 기본이기 때문에 나누기 시 몫과 나머지로 처리되어 결과가 나오고 이것은 2개의 레지스터에 나누어 저장된다.
      논리 연산 : 비트별로 AND, OR, XOR, NOT 등의 논리연산을 실행한다.
      쉬프트 연산 : 레지스터의 값을 왼쪽 또는 오른쪽으로 이동 시킨다. 보통 C(Carry)와 결합하여 실행되는 경우도 있다.
      FLAG : ALU에서 실행된 결과와 함께 여러 가지 보조결과를 저장한다.
      C (Carry) : 연산결과 MSB의 비트에서 발생하는 올림 또는 빌림의 결과를 저장한다.
      N (Negative, 또는 S (Sign)) : 정수형 표현에서 음수를 나타내는 비트인 MSB가 1인 경우를 나타낸다.
      Z (Zero) : 연산결과 모든 비트가 0임을 나타낸다.
      O (Overflow) : 연산결과 정해진 비트수를 벗어나 숫자가 변형된 상태를 나타낸다.
      초기에는 위의 요소로 구성 된 마이크로프로세서가 하나의 칩으로 만들어졌다. 그러나 마이크로컨트롤러(MCU)등이 나오면서 마이크로프로세서와 메모리 기타 컴퓨터를 이루는 요소들이 합쳐지기 시작했다. 8051등의 마이크로컨트롤러와 ARM 등이 그렇다. 따라서 한 칩에 마이크로프로세서 뿐만 아니라 기타 요소를 구분할 필요가 생긴다. 초기의 마이크로프로세서 모듈 만을 CPU 코어라는 말을 사용하기도 한다.
      
      구조
      마이크로프로세서 내부의 배열은 설계된 시기나 사용되는 목적에 따라 다양하다. 집적회로의 집약성은 한 개의 칩에 집적될 수 있는 트랜지스터의 개수, 연결 될 수 있는 배선의 개수, 칩이 견딜 수 있는 열의 한계 등에 따라 결정된다. 발전하는 기술은 더 복잡하고 강력한 칩을 생산 할 수 있게 만든다.
      
      가상의 최소한의 마이크로프로세서는 산술논리장치(ALU)와 제어 논리 섹션만을 포함할 수 있다. ALU는 덧셈, 뺄셈, 그리고 AND나 OR같은 연산을 수행한다. ALU의 각각의 연산은 상태 레지스터에 플래그를 모아서 마지막 연산의 결과를 표시한다. 제어 논리 섹션은 메모리로부터 지시 연산 코드를 되찾고, ALU의 연산의 결과가 실행하라고 하는 어떤 지시던지 실행한다. 한 개의 연산 코드는 경로, 레지스터, 그리고 프로세서의 다른 요소들에게 영향을 끼칠 수 있다.
      
      집적회로 기술이 발전하면서, 한 개의 칩에 점점 더 복잡한 프로세서를 생산할 수 있게 된다. 데이터 객체의 크기는 점점 더 커져지고, 칩에 더 많은 트랜지스터가 포함되는 것은 4비트나 8비트의 워드를 오늘날 64비트까지 늘릴 수 있게 한다. 프로세서 아키텍처에 추가적인 특징이 생겼다. 더 많은 온칩 레지스터는 프로그램의 속도를 높이고, 복잡한 명령은 더 정교한 프로그램을 가능하게 한다. 예를 들어, 부동소수점 연산은 8비트 마이크로프로세서에서는 가능하지 않았고, 소프트웨어 안에서만 실행되어야 했다. 부동소수점 유닛의 집적은 처음엔 분리된 집적회로에서 실현된 후에 단일 마이크로칩에서 실현되었고, 부동소수점의 연산의 속도를 높였다.
      
      가끔, 집적회로의 물리적인 한계가 비트 슬라이스 접근법 같은 실행이 필요하게 만든다. 긴 워드를 한 개의 집적회로에서 처리하는 대신에, 여러 개의 회로에서 각각의 데이터 워드를 병렬로 처리하는 방식이다. 이 방식이 추가적인 논리를 처리해야 하지만, 예를 들어, 각각의 슬라이스에서 올림이나 오버플로 같은, 즉 각각 4비트밖에 안 되는 집적회로가 32비트의 워드를 처리할 수 있게 한다. 한 개의 칩에 많은 수의 트랜지스터를 집적시키는 능력은 프로세서로서 한 개의 같은 다이에 메모리를 집적시키는 것을 가능하게 한다. 이 CPU 캐시는 오프칩 메모리보다 더 빠른 접근이 가능하다는 장점이 있고 시스템의 처리 속력을 증가시킨다. 최근을 제외하고는 프로세서의 클럭 수의 증가속도는 외장 메모리의 그것보다 더 빨랐고, 따라서 더 느린 외장 메모리가 프로세서를 지연시키지 않으려면 캐시 메모리가 필요하다.
      
      특수한 목적의 설계
      마이크로프로세서는 범용 시스템이다. 여러 개의 특화된 처리기기가 기술을 따라 발전해왔다. 마이크로컨트롤러는 임베디드 시스템에 지엽적인 기기와 마이크로프로세서를 집적시켰다. DSP는 신호처리에 특화되어있다. GPU는 없거나 제한되거나 아주 일반적인 프로그래밍 기능이 있다. 예를 들어 1990년대의 GPU는 대부분 프로그래밍이 불가능하거나 최근에 와서야 프로그램 가능한 버텍스 셰이더같은 제한된 기능이 생겼다.
      
      32비트 프로세서는 더 많은 디지털 논리를 가지고 있고, 더 많은 디지털 노이즈를 발생시키며, 더 높은 정적 소비전력을 가지고 있다.[3] 그래서 8비트나 16비트 프로세서가 32비트 프로세서보다 단일 칩 시스템이거나, 극히 저전력을 요구하는 경우가 많으며 고해상도 아날로그 디지털 신호 변환기와 같은 노이즈에 민감한 온칩 아날로그 전자기기에 포함되는 혼합 신호 집적회로의 부분으로서는 더 적합하다.
      
      비슷한 공정으로 생산될 때, 8비트 마이크로프로세서는 32비트 마이크로프로세서보다 작동할 때나 작동하지 않을 때 더 적은 전력을 소비한다.
      
      하지만, 일부는 부동소수점 연산같은 작업에서 32비트 마이크로프로세서보다 8비트 프로세서가 더 많은 클럭의 회전을 하기 때문에, 평균적으로 8비트 프로세서가 더 많은 전력을 소비한다고 한다.
      
      마이크로프로세서 동작
      동작 주기에 의한 마이크로프로세서 동작
      <nowiki /> 이 부분의 본문은 명령 주기입니다.
      컴퓨터가 동작한다는 말은 곧 마이크로프로세서가 연속적으로 명령 주기를 반복하여 기계어 코드를 실행한다는 말과 같다. 프로그래밍에 의해 만들어진 메모리 속의 기계어 코드를 실행함으로써 컴퓨터가 사용자가 원하는 기능을 수행한다.
      
      마이크로프로세서 동작 모드
      권한 수준
      운영 체계를 설계할 때, 마이크로프로세서가 응용 프로그램 실행인지 시스템 실행인지에 따라 특정 기능을 제약할 수 있다. 예를 들어 커널을 동작 시킬 때 모든 기계어 명령은 동작하나, 사용자 모드에서 하드웨어 관련 기계어 명령은 제한할 수 있다.
      
      동작 모드 :
      
      슈퍼바이저 모드 : 전원이 인가되고 리셋 신호가 오거나 예외상황(인터럽트 등)이 발생하면 이 동작 모드로 전환된다. 운영 체제의 커널 실행이 대표적 모드이다. 사용자의 요청에 의한 응용 프로그램을 실행할 때는 커널이 사용자 모드로 전환하면서 응용 프로그램용 기계어 코드를 실행한다.
      사용자 모드(사용자 공간) : 사용자의 요청에 의해 실행되는 응용 프로그램 실행 시 작동하는 모드이다. 컴퓨터 시스템은 여러개의 프로세서가 동작하는 것이 일반적이기 때문에, 각 응용 프로그램을 시간을 분할하여 실행할 필요가 있다. 어느 한 프로세서가 동작하다가 워치독 타이머나 기타에 의한 인터럽트에 의해 프로세서가 강제 종료되어 커널(슈퍼바이저 모드)로 전환된다. MMU가 존재하는 컴퓨터 시스템에서는 응용 프로그램이 이 기능을 사용하기 때문에 메모리 액세스 할 때 동작한다.
      각 마이크로프로세서마다 구별되는 방식은 차이가 있다. x86 계열은 0,1,2,3 등 4단계의 링 구조로 되어 있고, 68000 계열은 두 단계로 나누어 있다.
      
      아이들 모드
      마이크로프로세서가 특정 일을 할 필요가 없거나, 전원 등의 이유로 동작을 멈추었다가 필요할 때 동작을 재게할 수 있도록 할 수 있다. 마이크로프로세서가 동작을 멈추는 상태를 아이들 모드(idle mode) 또는 슬립 모드(sleep mode)라고 한다. 이 모드 상태가 되면 최저 전력이 사용된다. 보통 하드웨어로 깨울 수 있는 방식을 많이 사용한다. 이 모드로 전환을 위해 기계어 명령이 제공된다. 경우에 따라 마이크로프로세서에서 사용하는 클럭 회로도 제어할 수 있다.
      
      임베디드 애플리케이션
      전통적으로는 컴퓨터와 관련되어 있지 않은 수많은 제품들이 마이크로프로세서를 포함한다. 이것들은 크거나 작은 가전제품, 차, 차키, 공구와 테스트 기기, 장난감, 전등 스위치나 전기회로 차단기를 포함한다. 휴대폰, dvd비디오 시스템, hdtv방송시스템 같은 것들은 기본적으로 강력하고 저비용인 마이크로프로세서를 필요로 한다. 최근에 엄격해진 환경 오염 통제 기준은 자동차의 다양한 주행 상황에 대응하여 최적의 배출 조절을 위해 마이크로프로세서 엔진 관리 시스템을 요구한다.
      
      마이크로프로세서 컨트롤 프로그램(임베디드 소프트웨어)는 제품의 재설계를 최소화하면서 성능의 업그레이드를 시키면서, 제품 라인의 다양한 요구에 맞춰 설계될 수 있다.
      
      시스템의 마이크로프로세서 컨트롤은 전자기계컨트롤이나 목적이 정해진 전자 제어기는 불가능한 제어 전략을 제공한다. 예를 들어 자동차의 엔진 관리 시스템은 엔진의 속도나 부담, 내부의 온도, 그리고 다른 상황의 정보에 맞춰서 자동차가 연비에 맞게 주행할 수 있도록 점화타이밍을 조절 할 수 있다.
      
      같이 보기
      마이크로아키텍처`,
    },
    {
      id: 12,
      title: "전자 회로",
      contents: `전자 회로(電子回路, 영어: electronic circuit)는 다이오드, 저항기, 유도자, 콘덴서, 트랜지스터와 같은 개별적인 전자 부품들(electronic components)로 구성된 전기회로이다.

      전자공학에서 주로 능동소자를 활용한 회로로 해석하지만 능동소자만으로 회로 구성을 할 수 없으므로 수동소자를 같이 사용한다. 연산 증폭기는 능동소자로 구성된 회로이므로 전자 회로이며, 이의 해석을 한다. 수동소자만으로 구성된 회로는 회로 이론(영어: network analysis)에서 해석하고, 전자 회로와는 구별된다.
      
      능동소자는 이론적 측면에서는 소자자체로는 해석이 불가능하므로 수동소자와 전압 소스 그리고 전류소스로 모델링하여 변환 후, 회로 이론으로 해석한다. 증폭기 등, 주파수에 의해서 저주파와 고주파로 나누어 모델링하고 해석하는 경우도 있다.
      
      증폭기를 설계하는 경우가 많으므로 이의 회로와 해석을 기본으로 한다. 단순 신호를 증폭하는 단순 증폭기, 필터회로 등과 결합한 복합 회로도 가능하다. 그리고 각종 신호 발생기 등의 응용 분야도 있다. 통신회로에 사용하는 필터와 같은 응용 분야 등도 전자회로를 사용한다.
      
      논리 회로 분야는 논리 회로(디지털 회로), 아날로그-디지털 변환회로, 디지털-아날로그 변환회로로 나눌 수 있다. 이것은 주로 능동소자의 스위칭 기능을 활용 한다.
      
      증폭기나 응용분야에서 주파수에 의해서 저주파 회로, 고주파 회로로 나누는 경우도 있다. 초고주파 응용 분야에선 Si 소자를 벗어나 다른 소재의 반도체를 사용하기도 한다.
      
      구성 요소
      신호 처리를 위해 능동소자가 주로 취급하고 이와 수동소자(저항기, 코일, 축전기)가 결합하여 회로를 구성 한다.
      
      능동소자
      증폭, 정류같은 능동 동작이 가능한 반도체 공학 소자
      
      다이오드, 트랜지스터(BJT, FET), 사이리스터
      집적회로
      기타
      전자관
      센서
      액츄에이터
      회로 해석
      회로 해석에서 능동소자는 수동소자와 전압 · 전류 소스로 모델링 한다. 이 모델링 변환을 통해 회로 이론을 사용하여 해석을 통해 입력에 의한 출력을 알 수 있다.
      
      
      (그림 1) 저주파수 BJT hybrid-pi 모델.
      
      증폭기 등에서 해석해야 할 내용 :
      
      증폭도(gain) : 주로 선형회로로 간주하고 해석한다.
      소자의 입력 임피던스
      소자의 출력 임피던스
      주파수 특성을 알기 위해 보데선도(Bode plot) 해석
      능동소자는 주파수 특성을 알기 위해 저주파용과 고주파용의 모델링으로 나뉜다. 주로 C의 성분이 적어서 고주파에서 추가 된다.
      
      해석 방법
      접합형 트랜지스터와 전계효과 트랜지스터를 활용한 증폭기
      BJT나 FET을 활용해서 증폭기를 만들 경우, 전류 방향이 한쪽으로만 흐르기 때문에 AC 성분을 증폭하려면 음전압 부분을 없애기 위해 바이어스를 통해 해결해야 한다. 따라서 이것은
      
       DC소스 + AC소스 신호
      의 결합 형태로 해석 하면 된다.
      
      전원이 2개라고 생각하면 각각의 소스로 해석하는 중첩 원리로 해석하면 된다. 보통 DC 전압이 높고, 신호로 입력되는 전압 폭이 작기 때문에 소신호라는 용어를 사용한다.
      
      DC 해석 (동작점, Q-point)
      DC을 넣는 방법은 R을 사용한다. 전체 전원에 디바이더를 사용하여 동작점(Q-point) 전압을 얻는다. 이것을 신호와 분리하기 위해 C을 앞에 넣어 분리 한다. 따라서 C을 사용하여 AC 전원을 분리 한다. 즉, 회로에서 제거하고 해석한다.
      
      소신호 해석
      중첩의 원리에 따라 DC을 제거하기 0V로 놓으면 된다. C는 short로 연결하면 된다. 이렇게 하고 소신호모델을 적용해서 회로 이론으로 해석한다.
      
      연산 증폭기
      연산 증폭기의 해석은 연산 증폭기의 입력의 특성을 이용한다.
      
      입력 단자 
      �
      +
      {\displaystyle v_{+}}와 
      �
      −{\displaystyle v_{-}} 전압이 같다.
      입력 단자 
      �
      +
      {\displaystyle v_{+}}와 
      �
      −{\displaystyle v_{-}} 전류는 0이다.
      이 개념을 적용하여 회로 이론을 적용해 해석한다. 위 조건을 사용하여, KCL을 적용하여 수식을 전계하여 증폭도등을 얻을 수 있다. 기타 C성분이 추가되는 필터회로의 경우 주파수 특성해석까지 추가되어 해석한다. 주파수 특성을 쉽게 파악하기 위해 보데선도를 이용한다.
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      전자 회로
      
      전기 회로, 회로 이론
      자기 회로
      전자공학, 반도체공학, 전기공학
      제어공학, 전기계측 공학
      전자공학 용어 목록
      노이즈
      저항의 양자 노이즈
      저항의 열 노이즈
      화이트 노이즈
      칼라 노이즈`,
    },
    {
      id: 13,
      title: "컴퓨터 프로그래밍",
      contents: `컴퓨터 프로그래밍(영어: computer programming) 또는 간단히 프로그래밍(programming, 문화어: 프로그램 작성) 혹은 코딩(coding)은 하나 이상의 관련된 추상 알고리즘을 특정한 프로그래밍 언어를 이용해 구체적인 컴퓨터 프로그램으로 구현하는 기술이다.[1] 프로그래밍은 기법, 과학, 수학, 공학, 심리학적 속성들을 가지고 있다.

      한편 코딩은 '작업의 흐름에 따라 프로그램 언어의 명령문을 써서 프로그램을 작성하는 일' 또는 '프로그램의 코드를 작성하는 일'로 크게 나누어 언급되고 있는데 이는 알고리즘과의 상관관계를 잘 언급하고 있다.
      
      프로그래밍 언어
      <nowiki /> 이 부분의 본문은 프로그래밍 언어입니다.
      
      에이다 러브레이스, 최초의 컴퓨터 프로그래머.
      특정한 프로그래밍 언어로 쓰인 프로그램은 기계어로 번역되어 컴퓨터에 의해 실행되며, 어떤 프로그래밍 언어도 기계어로 번역이 가능하다. 어떤 언어에서는 기계어 대신 p-부호로 불리는 바리를 생성하기도 한다. 프로그래머가 기계 부호로 직접 작성하는 것도 가능하지만, 이는 굉장히 어려운 작업이다. 때문에 낮은 수준에서의 컴퓨터 제어가 필요한 경우 프로그래머들은 기계어 명령어에 대한 일대일 연상 기호 대응인 어셈블리어를 사용한다.
      
      서로 다른 프로그래밍 언어는 다른 프로그래밍 유형을 지원하기 때문에, 분야에 따라 적합한 언어가 존재한다. 또한 언어마다 프로그래머가 알고리즘을 구현할 때 그 구체적인 방법과 수준의 차이가 있기 때문에, 사용의 편의성과 성능 사이에서 적절한 타협이 이루어진다. 또한 프로그래밍의 언어 중 하나이며 컴퓨터에게 명령을 전달할 수 있다.
      
      소프트웨어 개발
      <nowiki /> 소프트웨어 공학 문서를 참고하십시오.
      소프트웨어는 컴퓨터 프로그램과 데이터를 총칭하는 용어이다. 이에 수반한 문서 자료는 소프트웨어의 필수 요소로 간주되지만, 실제 프로그래밍 과정에 포함되는 것은 아니다.
      
      소프트웨어의 제작은 아래와 같은 과정을 포함한다:
      
      특정 문제를 해결하기 위한 프로그램의 요구를 인지한다.
      프로그램을 기획하고, 도구(하드웨어 플랫폼과 프로그래밍 언어를 포함한)를 선택한다.
      프로그램 언어를 사용하여 프로그램을 제작한다.
      테스트 등을 통하여 디버깅 과정을 거친다.
      일반 사용자에게 공개한 후, 지속적인 유지/보수를 한다.
      같이 보기
      프로그래밍 코드 작성
      관련 교육기관 : http://kgitcoding.co.kr/
      컨테스트
      ACM-ICPC
      구글 코드잼
      탑코더`,
    },
    {
      id: 14,
      title: "전자공학",
      contents: `전자공학(電子工學, electronics)은 전자의 운동과 그 응용 기술을 연구하는 학문이다. 구동력으로서 전력을 이용하는 구성장치, 시스템 또는 여러 장비(진공관, 트랜지스터, 집적회로, 프린트 배선 기판)들을 개발하기 위하여 전자들의 운동에 대한 영향과 행동에 대한 과학적 지식을 연구하는 공학의 한 분야로 힘, 기계공학, 원격통신학, 반도체 회로디자인, 그리고 다른 많은 부분체들을 포함하는 개념이다. 컴퓨터 공학의 하드웨어 디자인을 비롯해서 전자회로의 디자인과 구성은 전자공학의 한 분야로 특정 문제를 해결한다. 새로운 반도체의 소자에 관한 연구는 때때로 물리학의 한 분야로 분류된다. 전자공학이 적용되는 대표적인 산업으로는 통신, 컴퓨터, 반도체 산업 등이 있다. 전기통신 분야에서 진공관이 비약적인 발전을 이루어 텔레비전, 라디오, 컴퓨터, 레이다 등이 20세기 후반의 문명의 중심이 되면서 미국에서 태어난 개념이다. 기초적인 분야부터 응용면에 이르기까지 광범위한 내용을 지니고 있다..

      전기 전자 기술자 협회(IEEE, The Institute of Electrical and Electronics Engineers)는 전자공학 엔지니어에게 가장 영향력있는 기관중 하나이다.
      
      전문 용어
      전기공학이라는 용어는 전자공학을 포함하는 용어로 몇몇 연장(年長)의 (주로 미국과 호주에서) 대학교들과 졸업생들 사이에서 불린다. 몇몇 사람들은 전기공학이라는 용어를 그들이 전문적으로 가진 전력, 고전류, 고전압 공학분야에만 한정되어야 한다고 생각한다. 반면에 다른 사람들은 그 '전력'이 전기배선공학과 전기공학의 작은 일부분일뿐이라고 생각한다.(실제로 전력공학이라는 용어가 사용되고 있다.) 다시 최근 몇년동안 별개로 떨어져있던 분야들, 예를 들면 정보공학, 커뮤니케이션 시스템 공학 등 이 학문적으로 유사한 분야로 대두되고 있다.
      
      대부분의 유럽의 대학교들은 현재 전기공학이라는 용어를 전력공학으로써 전기전자공학과 별개의 것으로 간주하고 있다. 1980년대 시작된 컴퓨터 공학은 간혹 전자공학 또는 정보공학을 지칭하는 용어로 사용되었으나, 현재 컴퓨터 공학은 하드웨어 및 소프트웨어를 포괄하는 넓은 의미로 사용되고 있다.
      
      전자공학의 역사
      진공관 검파기(眞空管檢波器)
      3극진공관 증폭기, 발전기, 그리고 검파기의 발명은 라디오에 의한 음성 커뮤니케이션을 실용화하였다.(전기 기계 교류발전기에 쓰인 레저널드 페슨텐의 1906년 전파) 가장 처음으로 알려진 라디오 뉴스 프로그램은 미시간주 디트로이트시에서 8MK사에 의해 1920년 8월 31일에 방송되었다.(WWJ,AM) 그리고 재미를 위한 정식 무선방송은 1992년 마르코니 연구소(영국, 체므스포드)에서 개시하였다.
      
      초기 몇몇의 라디오들은 전류 또는 배터리를 통한 증폭 방식을 이용하였으나, 1920년대 중반 이후 대부분의 수신기는 크리스털 제품이 되었다. 1920년대 진공관을 이용한 증폭방식은 라디오 수신기와 송신기 모두에서 혁신적인 결과를 가져왔다.
      
      텔레비전
      1928년 필로 판즈워스는 순수하게 전자 텔레비전에 대한 첫 번째 공식적인 증명을 하였다. 1930년대 몇몇 국가들이 방송을 시작하는 동안에 2차 세계대전이 발발하였고 이로 인해 텔레비전 수상기의 수가 기하급수적으로 증가하여 텔레비전이 세계화가 되었다.
      
      현재 텔레비전, 비디오 디스플레이들은 플라즈마나 LCD 디스플레이같은 더욱 집적된 장치들을 사용하기 위하여 부피가 큰 전자 튜브 기술을 사용하고 있으며, 최근의 트렌드는 매우 적은 전력소비량을 가진 OLED(Organic Light-emitting diode)디스플레이 같은 것이며, LCD와 플라즈마 기술을 대체할 것으로 보인다.
      
      컴퓨터
      1941년 Konrad Zuse가 세계 최초의 기능성 컴퓨터인 Z3를 선보였으며, 1943년 Colossus 컴퓨터인 에니악(ENIAC, Electronic Numeracial Integrator and Computer) 이후 1946년 John Presper Eckert 와 John Mauchly에 의해 컴퓨터 시대가 열렸다. 컴퓨터의 수학적 이행능력은 엔지니어들에게 완전히 새로운 기술을 개발하고 새로운 목표를 갖게 하였으며, 컴퓨터를 이용한 단적인 사례로는 달 착륙을 위한 미국의 아폴로 미션을 들 수 있다.
      
      전자공학의 분류
      전자기학
      맥스웰 방정식을 포함한 전계와 자계에서 해석.
      회로이론(수동소자)
      R, L, C 등의 수동소자와 소스(source)로 구성된 회로망(network analysis)의 해석.
      반도체공학
      시스템프로그래밍
      전자회로(능동소자)
      D, BJT, FET 등으로 구성된 능동소자로 구성된 해석.
      디지털 회로 (논리회로, 마이크로프로세서, FPGA)
      불 대수를 기반으로하는 논리를 구현하기 위한 논리회로의 구성 방법, 설계, 해석.
      제어공학
      기계, 항공, 기타 제어 대상에 대해 제어 방법 및 해석
      초고주파공학 (RF, 마이크로웨이브)
      통신공학
      디스플레이공학
      항공전자
      같이 보기
      전기공학
      컴퓨터 공학
      데이터시트
      아날로그 신호 처리
      디지털 신호 처리 (DSP)
      IEEE
      메카트로닉스`,
    },
    {
      id: 15,
      title: "전자제품",
      contents: `전자제품(電子製品)은 컴퓨터, 휴대 전화, MP3 플레이어, 텔레비전, 컴퓨터 모니터, 계산기, 라디오, 냉장고, 에어컨, 세탁기, 디지털 카메라 등을 포함해 일상에서 자주 사용하는 전자공학 기기를 말한다.`,
    },
    {
      id: 16,
      title: "로봇",
      contents: `로봇(문화어: 로보트, 영어: robot)은 어떠한 작업이나 조작을 자동적으로 수행하는 기계장치다.

      인간하고 유사한 모습과 기능을 가진 기계 또는 한 개의 프로그램으로 작동하고(programmable), 자동적으로 복잡한 일련의 작업(complex series of actions)을 수행하는 기계적 장치를 말한다.
      
      또한 제조공장에서 조립, 용접, 핸들링(handling) 등을 수행하는 자동화된 로봇을 산업용 로봇이라 하고, 환경을 인식해 스스로 판단하는 기능을 가진 로봇을 '지능형 로봇'이라 부른다. 사람과 닮은 모습을 한 로봇을 '안드로이드'라 부르기도 한다.
      
      다른 뜻은 형태가 있으며, 자신이 생각할 수 있는 능력을 가진 기계라고도 한다. 인공의 동력을 사용하는 로봇은 사람 대신 또는 사람과 함께 일을 하기도 한다. 통상 로봇은 제작자가 계획한 일을 하도록 설계된다.
      
      로봇'이란 용어는 체코슬로바키아의 극작가 카렐 차페크(Karel Čapek)가 1920년에 발표한 희곡 "R.U.R"에 쓴 것이 퍼져 일반적으로 사용되게 되었다. 또한 로봇의 어원은 체코어로 "노동", "노예", "힘들고 단조로운 일"을 의미하는 robota이다.
      
      비유적으로는 남의 지시대로 움직이는 사람을 이르는 이르기도 한다.
      
      어원 및 정의
      어원
      Robot이라는 말은 1920년 체코슬로바키아의 극작가 카렐 차페크(Karel Čapek)의 희곡 R.U.R.(Rosuum' s Universal Robots)에서 처음 사용되었다.
      
      로봇의 어원은 체코어의 노동을 의미하는 단어 'robota'에서 나왔다고 알려지고 있다.
      
      차페크는 R.U.R.에서 모든 작업능력에서 인간과 동등하거나 그 이상이면서 인간적 “감정”이나 “혼”을 가지고 있지 않은 로봇이라고 불리는 인조인간을 등장시키고 있다. 로봇은 언젠가 쇠조각으로 변하여 반항하는 정신을 발달시킴으로써 자신들의 창조주인 인간을 전부 죽여 버린다고 하는 비극을 인상적으로 나타내고 있다.
      
      로보틱스(Robotics)라는 말은 로봇의 활용과 로봇 공학을 의미한다. 이 말은 미국 과학자이면서 작가인 아이작 아시모프(Issac Asimov; 1920년 1월 2일 ~ 1992년 4월 6일)가 1942년에 발간한 단편 Runaround에서 최초로 사용하였다.
      
      정의
      명사로서 로봇(robot)은 다음의 의미를 지닌다.
      
      『기계』 인간과 유사한 형태를 가지고 걷기도 하고 말도 하는 기계 장치
      『기계』 어떤 작업이나 조작을 자동적으로 하는 기계 장치
      남의 지시대로 움직이는 사람을 비유적으로 이르는 말
      카렐 차페크
      일할 수 있는 능력은 있어도 생각할 수 있는 능력이 없는 인간을 닮은 것.
      
      역사
      1921년 체코의 극작가 카렐 차페크가 자신의 형 요세프 차페크의 아이디어를 소설 'R.U.R', <로숨의 유니버설 로봇>에서 사용 처음 '로봇'이란 용어가 등장
      1959년 Unimate사에서 Joseph Engelber 등에 의해 최초의 산업용 로봇 개발
      1974년 신시내티사에서 최초의 컴퓨터로 제어되는 산업용 로봇 T3개발
      1979년 일본의 야마나시 대학교에서 SCARA(Selective Compliance Assembly Robot Arm)로봇 개발
      1997년 일본의 혼다에서 최초로 계단을 오르는 인간형 로봇 P2(아시모의 전신) 발표
      1999년 일본 소니에서 최초의 애완로봇 AIBO(Artificial Intelligence Robot) 출시
      2003년 미국 NASA에서 이동로봇 '스피릿'이 화성에서 탐사활동
      2006년 미국 보스톤 다이내믹스사의 빅 독 개발
      로봇의 3원칙
      <nowiki /> 이 부분의 본문은 로봇공학의 삼원칙입니다.
      아이작 아시모프가 1950년 발간한 소설인 'I'Robot'에서 제안된 로봇의 행동에 관한 3가지 원칙이다.
      
      제1법칙:로봇은 인간에게 해를 끼쳐서는 안 되며, 위험에 처해 있는 인간을 방관해서도 안 된다.
      제2법칙:로봇은 인간이 내리는 명령들에 복종해야만 하며, 단 이러한 명령들이 첫 번째 법칙에 위배될 때에는 예외로 한다.
      제3법칙:로봇은 자기 자신을 보호해야만 한다. 단, 제1법칙과 제2법칙을 걸러버릴경우는 예외다.
      군사용 로봇이 공격의 기능을 갖출 경우, 첫 번째 원칙에 위배되게 된다. 하지만 3원칙만 듣게되면 만약 예시로 로봇에게 지구에 있는 나무를 다 없애주라고 할 때 나무를 없애는 것이기 때문에 실행을 할 수가 있어 인간에게 위험할 수 있다. 그래서 몇몇 사람들은 이를 바꾸려고 한다.
      
      로봇의 이용
      그동안 인간이 해 오던 많은 일들을 지금은 로봇이 대신하고 있다. 산업 현장에는 단조로운 반복 작업이나 따분한 작업, 불쾌한 작업들이 많은데, 이와 같은 작업은 특히 로봇에게 맡기기에 적합하다. 조립 공장에서 리벳 박는 일, 용접, 자동차 차체를 칠하는 일 등은 그 좋은 예이다. 이런 종류의 작업은 로봇 쪽이 인간보다 더 잘 해낼 수 있다. 왜냐하면 로봇은 언제나 일정한 수준의 정밀도와 정확도로 작업을 계속할 수 있으며, 결코 지칠 줄 모르기 때문이다. 따라서 제품의 품질은 항상 일정하며 게다가 휴식을 취할 필요가 없기 때문에 많은 양의 제품을 만들 수 있다.
      
      또한 로봇은 위험한 작업을 대신할 수가 있다. 방호복을 입지 않고 원자력 공장에서 방사성 물질을 취급하거나, 유독 화학 물질을 취급할 수가 있으며, 인간에게는 너무 덥거나 추운 환경에서도 일할 수가 있다. 인간의 생명이 위험에 노출될 수 있는 곳에서도 로봇을 사용할 수 있다. 예를 들면 폭발물을 수색하거나 폭탄의 뇌관을 제거하는 일, 그리고 우주 공간에서의 작업도 그중의 하나이다.
      
      로봇은 우주 공간에서의 작업에 특히 이상적이다. 지구를 돌고 있는 인공위성을 수리하거나 유지하는 데 사용되기도 하고, 보이저호와 같이 탐사와 발견을 목적으로 먼 천체까지 비행하는 데도 로봇이 사용된다.
      
      한편 가정에서도 점점 많은 로봇이 가사를 돕기 위해 사용되고 있다. 그리고 육체적인 장애를 가진 사람들을 돌보는 일에도 많이 이용될 것으로 기대된다. 로봇 간호보조자는 장애자나 노령으로 인해 체력이 약해진 사람들이 가족들에게서 독립하여 혼자서도 살 수 있도록 해주며, 병원에 입원하지 않아도 될 수 있도록 도와 주게 될 것이다.
      
      로봇이 사용되는 분야의 예를 들면 다음과 같다.
      
      산업 및 의료용
      주로 힘이나 정밀도를 요하는 작업 담당
      
      자동차 조립
      전자제품 조립
      자동 운반 로봇
      수술 보조 로봇
      바다 탐사 로봇
      배달 로봇[1]
      수치 제어 공작 기계
      공장에서 제품을 생산할 때 컴퓨터를 이용하면, 제품의 생산 계획이나 설계·제조·보관·출고에 이르기까지 거의 모든 일을 처리할 수 있다. 기계 공업에서 가장 많이 사용하는 공작 기계는 금속 등을 가공할 때 사용된다. 과거에는 이 기계를 사용하기 위해 고도의 숙련된 기술이 필요했다. 그러나 최근에는 수치 제어 공작 기계가 개발되어 기술이 없어도 금속을 가공할 수 있게 되었다. 수치 제어 공작 기계는 가공하는 작업의 순서와 내용을 수치 정보로 만들어 기계에 입력시키면 기계가 자동적으로 가공 작업을 하는 것이다. 이 수치 제어 공작 기계와 자료의 입력 관리를 맡는 컴퓨터가 결합하여 만들어진 것이 컴퓨터 수치 제어 공작 기계이다. 이 수치 제어 기계에서 더 발전하여 복잡한 가공을 할 수 있도록 만든 장치가 공작 로봇이다.
      
      가정용
      주로 인내심을 요하는 작업 담당
      
      로봇 청소기
      애완용 로봇
      간병 로봇
      세탁 로봇
      군사 및 탐사용
      주로 위험한 환경에서의 작업 담당
      
      우주탐사선
      무인 정찰기
      폭발물 제거 로봇
      해저탐사선
      각국의 로봇
      미국
      미국에서는 로봇이 생활에 도움을 주는 기계라기보다 앞으로 인류를 위협할지도 모른다는 생각이 있어서 주로 터미네이터 등 영화에서 로봇이 인류를 위협하는 존재로 나와 있다. 또 무인 조종 비행기 등 군사에서 쓰는 군사 로봇이 가장 잘 발달되어 있다.
      
      2015년, 미국의 로봇 제조사인 한슨 로보틱스(Hanson Robotics)에서 일상을 위한 최신 인공지능 로봇 , '(Han)'을 공개하였다. 한은 사람과 대화를 할 수 있는 건 물론, 사람의 표정, 성, 나이 등을 캐치할 수 있다. 한의 가장 놀라운 점은 인간같은 표정을 지을 수 있다는 것이다.[2]
      
      일본
      일본 에도 시대에는 자동인형에 해당되는 가라쿠리 인형이 있었으며, 1929년에는 근대기술을 이용한 동양 최초의 로봇인 가쿠텐소쿠를 처음 제작하였다.
      
      2000년대 들어 아시모 등과 같은 휴머노이드형 로봇이나 소니의 AIBO와 같은 애완용 로봇 그리고 산업용 로봇 외에도 인간의 모습에 가까운 로봇 개발에 힘쓰고 있다. 아톰, 건담 같은 로봇 애니메이션이 대중적인 인기를 얻고 있다.
      
      중국
      중국에서는 로봇을 산업이나 가정에 도움을 주는 기계라보다는 사람이 조종하는 꼭두각시라고 생각한다. 그러나 중국은 미국과 일본, 심지어는 대한민국까지도 로봇공학에 힘을 쏟고 있다는 것을 인식하자 이들에게 뒤떨어지지 않기 위해 2000년에 선행자(先行者)라는 이름의 직립보행형 로봇을 개발하기도 했으나 선행자의 양 다리 사이에 설치된 파이프 모양의 부속으로 인하여 일본에서 '최종중화병기 선행자'라는 애니메이션이 발표되는 등 개그캐릭터로서 폭발적인 인기를 끌기도 했다.
      
      중국에서는 최근 중국 로봇산업의 발전을 위해 많은 노력을 기울이고 있다.
      
      한국
      조선시대에 물의 힘으로 여러 인형이 작동하는 물시계 자격루와 옥루를 제작한 적이 있으나, 현대적인 개념의 로봇이 들어온 것은 1978년 현대자동차 울산 제2공장에 일본에서 수입한 스풋용접용 로봇이 설치된 것이 처음이다.[3]
      
      1984년 6월 대우중공업 인천연구소에서 다관절형 아크용접 로봇 NOVA-10과 제어장치를 처음 국산화하였으며, 1980년대 후반 LG산전 등의 대기업들이 산업용 로봇을 본격적으로 생산하기 시작하였다.[3] 1988년에는 10여개의 로봇 생산업체가 약 1,200여대의 산업용 로봇을 생산하는 수준까지 성장하였으나, 1997년 IMF 사태를 계기로 빈약한 로봇 관련 내수시장과 기술의 취약 등으로 인해 산업용 로봇을 제품화하는 것은 사실상 중단되었다.[3][4]
      
      1990년대부터는 로봇청소기를 비롯한 서비스 로봇과 휴머노이드형 로봇이 개발 생산되기 시작하였다. 1997년 한국과학기술연구원(KIST)에서 제작한 '센토'가 비록 반인반마의 형태였으나 한국 최초의 휴머노이드 로봇으로 공개되었으며, 2002년에는 한국과학기술원 (KAIST)에서 'KHR-1'을, 2004년에는 '휴보 (KHR-2)'를 개발했다.[4]
      
      물리적인 움직임 없이 사람과 의사소통하며 감정을 교류하는 소셜 로봇도 있다. 예를 들면, 2015년 5월 글로벌 크라우드 펀딩 사이트인 인디고고(Indiegogo)를 통해 처음으로 세상에 소개된 뮤지오가 있다.
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      로봇
      로켓
      군사용 로봇
      iRobot
      팩봇(영어판)
      지능형 로봇
      로봇공학 (로보틱스)
      로봇수술
      사이버네틱스
      컴퓨터
      휴보
      인공지능
      인공생명
      휴머노이드
      액트로이드(영어판)
      뮤지오
      하디맨`,
    },
    {
      id: 17,
      title: "이산수학",
      contents: `이산수학(discrete mathematics, 離散數學, 문화어: 리산수학)은 이산적인 수학 구조에 대해 연구하는 학문으로, 연속되지 않는 공간을 다룬다. 유한수학(finite mathematics)이라고도 하며, 전산학적인 측면을 강조할 때는 전산수학이라고도 한다.

      이산수학에서는 실수 같이 연속적인 성질이 있는 대상이 아니라 주로 정수, 그래프, 논리 연산 같이 서로 구분되는 값을 가지는 대상을 연구한다. 따라서 이산수학에서는 미분적분학이나 수치 해석같이 '연속적'인 분야에서 다루는 주제는 다루지 않는다. 이산적인 대상은 정수로 개수가 열거되는 경우가 많다. 공식적으로, 이산수학은 가산집합을 다루는 수학의 한 부류로 특징지을 수 있다. 하지만 이산수학이라는 용어에 대해 정확한 정의는 내려져 있지 않다. 사실, 이산수학은 포함된 주제에 의해서 정의되기 보다는, 이산수학이 다루는 주제가 아닌 것들에 의해서 정의된다.
      
      이산수학에서 연구하는 집합의 종류는 무한 혹은 유한집합이다. 이산 수학중에서도 유한 집합을 다루는 한 분야에 대해서 가끔씩 유한 수학이라는 용어가 쓰이기도 한다.
      
      이산적인 과정을 통해서 데이터를 저장하고, 동작하는 디지털 컴퓨터의 개발으로 인해 20세기 후반에 이산수학에 대한 연구가 점점 활기를 띄기 시작했다. 이산수학에 포함된 개념과 기호들은 컴퓨터과학자들이 알고리즘, 프로그래밍 언어, 암호학, 계산이론 등의 문제를 연구하는 데 유용하였다.
      
      이산수학에서 두각을 나타내는 논문에게는 풀커슨상이 수여된다.
      
      이산수학의 과거와 현재
      현재 많은 대학교 컴퓨터과학 관련 학과에서 해당 학문을 전공 과목으로서 채택하고 있다. 유명한 저자는 Kenneth H. Rosen 이 있다.
      
      이산수학의 주제
      수리논리학
      집합론
      수론
      조합론
      그래프 이론
      알고리즘
      정보이론
      오토마타 이론
      계산 가능성 이론
      계산 복잡도 이론
      확률론
      선형대수학
      함수
      순서 집합
      증명 이론
      계수와 관계
          `,
    },
    {
      id: 18,
      title: "자동기계",
      contents: `자동기계 (自動機械) 또는 오토머튼(영어: automaton, 복수형은 영어: automata (오토머터)[*])은 스스로 작동하는 기계이다. 이 낱말은 종종 로봇, 특히 인간의 지속적인 조종이 없어도 스스로 움직이는 자동 로봇을 뜻하는 말로 쓰인다. 현대 산업에서는 자동 제어 기계(영어: automation)를 뜻하기도 한다.[1]

      어원
      영어 Automaton은 그리스어: αὐτόματον를 라틴어화한 것으로 "스스로의 뜻대로 움직이는"이란 뜻을 가지고 있다. 자동기계로 불리는 기계들은 전기 에너지를 사용하지 않고 오직 기계 장치만으로 이루어져 있으며 사람이나 동물이 관여하지 않아도 스스로 움직이는 것을 뜻하는 경우가 많았다. 이런 의미의 자동 기계는 뻐꾸기 시계를 대표적인 예로 들 수 있다. 시간마다 뻐꾸기가 시계 밖으로 나와 소리를 내는 장치를 지닌 뻐꾸기 시계는 태엽 장치를 동력으로 작동되었다.
      
      고대 자동기계
      헬레니즘 문명 시대의 자동기계로는 장난감, 종교적 우상, 기초 과학 이론을 보여주는 도구 등이 있었다. 고대 그리스의 수학자 알렉산드리아의 헤론은 수력으로 작동하는 오르간, 소화기, 사이펀과 같은 기계들에 대한 기록을 남겼다. 이 기록들은 16세기에 재발견되어 라틴어로 번역되었다. 헤론의 기록 가운데는 증기를 이용하여 회전하는 공이 언급되어 있으며, 이는 종종 최초의 자동기계로 여겨진다.[2]
      
      1900년 발굴된 안티키티라 메커니즘은 고대 그리스의 자동기계 부품으로 여겨지고 있다. 아르키메데스는 스스로 작동하는 천체 모형을 제작하였다고 한다.[3]
      
      신화속 자동기계
      유대교의 전설 가운데는 솔로몬의 왕좌가 기계로 된 동물들에 의해 받들어져 있었다는 이야기가 전해진다. 솔로몬이 왕좌에 오르면 기계 장치가 작동하여 토라가 있는 곳까지 움직였다는 것이다.[4]
      
      기원전 3세기 무렵 쓰인 고대 중국 춘추 시대의 책 열자에는 주무왕이 순행 중에 언사(偃師)가 만든 창우(倡優)라는 등신대의 움직이는 인형을 보았다는 기록이 있다.[5]
      
      중세의 자동 기계
      
      알 자자리의 자동 인형 악대를 묘사한 그림
      중세는 이슬람 세계의 과학이 크게 발전한 시기였다.
      
      8세기 중엽, 바그다드에서 풍력으로 작동하는 동상이 만들어졌다. 이 동상은 "바그다드의 네 문마다 돔위에 얹혀져 바람이 불면 회전하였다"고 한다.[6]
      
      12세기의 이슬람 과학자 알 자자리는 음료 시중을 드는 자동인형, 자동으로 여닫히는 문과 같은 자동 기계를 개발하였다.[7] 알 자자리는 자동 기계로 된 악대를 꾸며 음악을 연주하게 하였다고도 한다.[8]
      
      근대 초기의 자동 기계
      
      19세기에 제작된 일본의 차 따르는 카라쿠리 인형
      르네상스와 근대 초기에 다양한 지역에서 자동기계들이 제작되었다.
      
      레오나르도 다빈치는 움직이는 갑옷 인형을 고안하였다. 그러나 비행기나 전차와 같은 다빈치가 그린 여러 설계도와 같이 실제 만들어지지는 않았다.[9] 르네상스 시대 이탈리아의 기술자인 지오바니 폰타나는 기계 악마, 로켓과 플로펠러로 날아다는 동물과 같은 자동인형을 제작하였다.[10]
      
      16세기, 유럽의 여러 도시에서는 다양한 대형 시계 들이 제작되었다. 이 가운데는 시간에 맞추어 자동인형이 움직이는 장치를 갖춘 것들도 있었다. 이러한 시계 기술의 발달에 힘입어 18세기 유럽에서는 들어 수 많은 자동기계들이 제작되었다. 18세기에서19세기의 기간 동안 복잡한 기계 장치를 갖춘 매우 정교하게 움직이는 자동인형들이 제작되었다.[11]
      
      동아시아에서는 11세기에 송나라 시대 중국에서 인형이 움직이는 물시계를 제작하였다고 하며, 원나라와 명나라에서도 이와 비슷한 시계를 제작하였다. 조선에서는 15세기 세종때 장영실이 제작한 옥루는 시간에 맞추어 인형들이 움직이고 스스로 소리를 내는 장치를 갖추고 있었다.[12] 18세기 말 일본에서는 에도 시대에 태엽 장치를 갖춘 카라쿠리 인형을 제작하였다.
      
      여러 가지 자동 기계의 모습
      Baud museum mg 8561.jpg	Baud museum mg 8478.jpg
      Automaton.JPG	CIMA mg 8239.jpg
      같이 보기
      오토머튼 시계
      안드로이드
      에니메트로닉스
      메카트로닉스
      로봇공학
      `,
    },
    {
      id: 19,
      title: "알고리즘",
      contents: `알고리즘(영어: algorithm), 셈법은 수학과 컴퓨터과학, 언어학 또는 엮인 분야에서 어떠한 문제를 해결하기 위해 정해진 일련의 절차이다. 계산을 실행하기 위한 단계적 절차를 의미하기도 한다. 즉, 문제 풀이에 필요한 계산절차 또는 처리과정의 순서를 뜻한다. 프로그램명령어의 집합을 의미하기도 한다.

      알고리즘은 연산, 데이터 마이닝(기계 학습) 또는 자동화된 추론을 수행한다.
      
      이름
      산법(算法), 셈법, 계산절차(計算節次)라고도 한다.
      
      알고리즘은 9세기 페르시아의 수학자인 무함마드 알콰리즈미의 이름을 라틴어화한 알고리스무스(Algorismus)에서 유래한 표현이다.
      
      영어로 Algorithm의 발음 기호는 /ˈælɡəˌɹɪðəm/ 또는 /ˈælɡəˌɹɪðm̩/이며 Algorithm을 '알고리즘'으로 표기하는 것은 This를 '지스'로, Rhythm /rɪðəm/을 '리즘'으로 표기하는 것과 마찬가지의 잘못된 것이라는 주장이 있다. 하지만 실제 생활에서는 알고리즘이라는 표기가 알고리듬이라는 표기에 비해 압도적으로 많이 사용되고 있다.[1]
      
      정의
      <nowiki /> en:Algorithm characterizations 문서를 참고하십시오.
      멈춤문제의 결과로 알고리즘멈추기까지 걸리는 시간을 일반적으로 측정할 수 없다.
      
      그러므로 알고리즘에 대해 단순한 직관을 만족하는 형식적인 정의는 불가능하다.
      
      따라서 알고리즘의 공식적인 정의는 없다.
      
      대부분의 알고리즘은 유한한 수의 규칙에 따라 구별 가능한 기호들을 조작하여 입력 정수에서 출력 정수를 생성하기 위한 일반화된 작업을 정의한다. 다음은 좋은 알고리즘의 특징이다.
      
      정밀성 : 변하지 않는 명확한 작업 단계를 가져야 한다.
      유일성 : 각 단계마다 명확한 다음 단계를 가져야 한다.
      타당성 : 구현할 수 있고 실용적이어야 한다.
      입력 : 정의된 입력을 받아들일 수 있어야 한다.
      출력 : 답으로 출력을 내보낼 수 있어야 한다.
      유한성 : 특정 수의 작업 이후에 정지해야 한다.
      일반성 : 정의된 입력들에 일반적으로 적용할 수 있어야 한다.
      구현
      알고리즘은 자연어, 의사코드, 순서도, 프로그래밍언어, 인터프리터가 작업하는 제어테이블, 유한상태기계의 상태도 등으로 표현할 수 있다. 다음은 알고리즘 개발의 정형적인 단계이다.
      
      문제 정의 → 모델 고안 → 명세 작성 → 설계 → 검증 → 분석 (복잡도 등) → 구현 → 테스트 → 문서화
      알고리즘을 설계하는 기술에는 운용과학의 방법, 설계짜임새를 써먹는 방법 등이 있다. 대부분의 알고리즘은 컴퓨터 프로그램으로 구현되지만, 전기 회로나 생물학적 신경회로를 사용하기도 한다.
      
      분류
      구현 : 재귀적 알고리즘, 연역적 알고리즘, 결정론적 알고리즘, 근사 알고리즘, 양자 알고리즘 등.
      설계 : 무차별 대입 공격, 분할 정복 알고리즘, 그래프 순회, 분기 한정법, 확률적 알고리즘, 리덕션, 백트래킹 등.
      최적화 문제 : 선형 계획법, 동적 계획법, 탐욕 알고리즘, 휴리스틱 함수 등.
      이론적 분야 : 검색 알고리즘, 정렬 알고리즘, 수치 알고리즘, 그래프 알고리즘, 문자열 알고리즘, 암호학적 알고리즘, 기계 학습, 데이터 압축 등.
      복잡성
      <nowiki /> 이 부분의 본문은 시간 복잡도입니다.
      입력의 크기가 
      �
      n일 경우, 점근 표기법 
      �
      O를 사용하여 다음과 같이 나타낸다.
      
      �
      (
      1
      )
      O(1) : 
      �
      n에 관계없이 일정 시간 이하에 수행되는 알고리즘이다. 예) 파일의 첫 번째 바이트가 널(null)인지 검사하는 것.
      �
      (
      log
      ⁡
      �
      )
      {\displaystyle O(\log n)} : 
      log
      2
      ⁡
      �
      {\displaystyle \log _{2}n}에 비례하는 시간 이하에 수행되는 알고리즘이다. 예) 이진 탐색.
      �
      (
      �
      )
      O(n) : 
      �
      n에 비례하는 시간 이하에 수행되는 알고리즘이다. 예) 기수 정렬.
      �
      (
      �
      log
      ⁡
      �
      )
      {\displaystyle O(n\log n)} : 
      �
      n에 대략 비례할 수 있는 시간 이하에 수행되는 알고리즘이다. 예) 정렬 알고리즘.
      �
      (
      �
      2
      )
      O(n^{2}) : 
      �
      2
      n^2에 비례하는 시간 이하에 수행되는 알고리즘이다. 예) 최장 공통 부분 수열 문제.
      �
      (
      �
      3
      )
      {\displaystyle O(n^{3})} : 
      �
      3
      {\displaystyle n^{3}}에 비례하는 시간 이하에 수행되는 알고리즘이다. 예) 행렬 곱셈.
      �
      (
      �
      �
      )
      {\displaystyle O(a^{n})} : 
      2
      �
      2^{n}과 같은 꼴의 수행 시간 이하에 수행되는 알고리즘이다. 예) 충족 가능성 문제.
      �
      (
      �
      !
      )
      {\displaystyle O(n!)} : 
      �
      !
      n! 즉 
      �
      ×
      (
      �
      −
      1
      )
      ×
      (
      �
      −
      2
      )
      ×
      .
      .
      .
      ×
      1
      {\displaystyle n\times (n-1)\times (n-2)\times ...\times 1}과 같은 꼴의 수행 시간 이하에 수행되는 알고리즘이다. 예) 배열의 모든 순열을 검사하는 것.
      대문자 O 표기법의 정의상 아래의 복잡도는 그 위의 복잡도를 포함하므로, 대부분의 알고리즘은 
      �
      (
      �
      !
      )
      {\displaystyle O(n!)}의 수행 시간을 가진다.
      
      예
      <nowiki /> 이 부분의 본문은 알고리즘의 목록입니다.
      알고리즘의 예시
      가장 단순한 알고리즘 가운데 하나는 임의로 나열된 숫자들 가운데 가장 큰 수를 찾는 것이다. 다음은 목록 안에 있는 모든 수를 살펴보는 알고리즘이다.
      
      알고리즘 LargestNumber
        Input: A list of numbers L.
        Output: The largest number in the list L.
        if L.size = 0 return null
        largest ← L[0]
        for each item in L, do
          if item > largest, then
            largest ← item
        return largest
      "←"은 대입을 가리킨다. 이를테면 "α ← β"는 α에 β를 대입하는 것을 뜻한다.
      "return"은 알고리즘을 종료하고 다음의 값을 출력한다.
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      알고리즘
      Garbage in, garbage out
      Introduction to Algorithms
      계산 이론
      고속 푸리에 변환
      라메의 정리
      람다 대수
      순서도
      알고리즘 트레이딩
      처치-튜링 명제
      추상 기계
      휴리스틱 이론
      기사의 여행
      스테인하우스-존슨-트로터 알고리즘`,
    },
    {
      id: 20,
      title: "C",
      contents: `C는 1972년 켄 톰슨과 데니스 리치가 벨 연구소에서 일할 당시 새로 개발된 유닉스 운영 체제에서 사용하기 위해 개발한 프로그래밍 언어이다. 켄 톰슨은 BCPL언어를 필요에 맞추어 개조해서 "B"언어(언어를 개발한 벨 연구소의 B를 따서)라 명명했고, 데니스 리치가 이것을 개선하여 C 언어가 탄생했다. 유닉스 시스템의 바탕 프로그램은 모두 C로 작성되었고, 수많은 운영 체제의 커널 또한 C로 만들어졌다. 오늘날 많이 쓰이는 C++는 C에서 객체 지향형이다.

      이는 오늘날의 널리 쓰이는 거의 모든 운영 체제 커널이 C를 이용해 구현된 이유이기도 하다. 이처럼 C는 시스템 프로그램 개발에 매우 적합하지만, 응용 프로그램 개발에도 많이 쓰이기도 한다.
      
      예제
      #include <stdio.h> //stdio.h 라는 헤더를 가져온다
      
      int main() { //메인메소드의 시작지점으로 , 메인메소드의 시작이라는걸 알려준다.
          printf("Hello World!"); //printf 구문과 Hello World! 로 Hello World를 출력한다.
          return 0; //숫자 0을 리턴해 프로그램을 종료한다.
      } //메인 메소드의 끝을 알린다.
      역사
      1963년 - ALGOL 60에서 CPL이 파생
      1969년 - BCPL 개발
      1970년 - B 언어 개발
      1972년 - 벨 연구소 (Bell Laboratories) 에 있는 Dennis Ritchie가 B의 후속으로 C 개발
      1983년 - 미국 국가 표준 협회(ANSI, American National Standards Institute)에서 짐 브로디(Jim Brodie) 주축으로 X3J11 위원회 소집
      1983년 12월 14일 - ANSI X3.159-1989 라는 공식명칭으로 C 언어 표준 지정
      1999년 - C99 표준안이 ISO/IEC 9899:1999라는 명칭으로 출간됨
      2000년 5월 - ANSI의 표준으로 C99가 채택됨
      2011년 - 12월 8일 C11 표준안이 ISO/IEC 9899:2011라는 명칭으로 출간됨
      2018년 - C17 표준안이 ISO/IEC 9899:2018이라는 명칭으로 출간됨[2]
      초기 개발
      
      C 언어의 개발자인 켄 톰슨과 데니스 리치.
      C 언어의 초기 개발은 1969년부터 1973년까지 4년에 걸쳐 AT&T 벨 연구소에서 이루어 졌으며,[3] 데니스 리치의 말에 따르면, 가장 창의적인 작업이 이루어진 기간은 1972년이었다. 언어의 이름이 'C'인 이유는 그 특징이 'B' 언어에서 유래되었기 때문이며, 켄 톰슨에 의하면, B 언어는 BCPL 언어의 기본만 남긴 버전이다.
      
      리치와 톰슨에 의해 초기에 PDP-7의 어셈블리 언어로 구현되었던 유닉스 운영체제의 개발과 C 언어의 기원은 밀접하게 연관되어 있다. 결국 그들은 유닉스 운영체제를 PDP-11로 포팅하기로 결정하였다. PDP-11의 기능의 일부, 특히 바이트 접근기능을 활용하지 못하는 B 언어의 부족함이 C 언어의 초기 버전의 개발을 이끌었다.
      
      유닉스의 초기 PDP-11 버전은 어셈블리로 개발되었다. 1973년에 struct 자료형의 추가로, C 언어는 유닉스의 대부분을 C로 쓸 수 있을 정도로 강력해 졌다. 유닉스는 어셈블리가 아닌 언어로 구현된 최초의 운영체제 커널 중의 하나였다.(더 빠른 사례는 PL/I로 쓰인 Multics 시스템, ALGOL로 쓰인 Burroughs B5000을 위한 MCP(Master Control Program)가 있다.) 1977년 경, 리치와 스티븐 C. 존슨이 유닉스 운영체제의 이식성을 향상시키기 위해, C 언어를 추가적으로 변경하였다. 존슨의 Portable C Compiler는 새로운 플랫폼에서의 C의 구현의 기초가 되었다.[4]
      
      K&R C
      
      The C Programming Language의 표지
      1978년에 브라이언 커니핸과 데니스 리치가 The C Programming Language라는 책의 초판을 출간했다. 커니핸과 리치의 앞 글자만 따서 C 프로그래머들에게는 "K&R"로 불리는 이 책은, 비공식적이지만 오랫동안 C의 규격과 같은 역할을 했다. 그리하여, 이 책에서 서술하는 C의 판이 "K&R C"란 명칭으로 불리게 되었고, 이 책의 2판에서는 후의 ANSI C 표준을 다루게 되었다.
      
      K&R에서 다음과 같은 기능이 등장한다.
      
      표준 입출력 라이브러리
      long int 자료형
      unsigned int 자료형
      =-와 같은 형태의 복합 대입 연산자를 -= 형태로 변경
      i=-10라는 코드가 원래 의도한 i =- 10 (i의 값을 10 차감)이 아닌, i = -10 (i의 값을 -10으로 설정)으로 해석될 수 있기 때문에 중의성을 없애기 위해서 형태를 변경했다.
      C99
      <nowiki /> 이 부분의 본문은 C99입니다.
      C 언어 표준이 상대적으로 정적으로 남아 있었던 동안, C++는 표준화를 위하여 계속 진화하고 있었다. 1995년에 1990년의 C 표준에 대한 규약 수정안 1이 출판되었는데, 이는 약간의 세부 사항을 교정하고 국제적 문자 세트에 대한 보다 확장된 지원을 위한 것이었다. C 표준은 1990년대 후반에 더 개정되어, 1999년 ISO/IEC 9899:1999가 출간되었고, 여기서 명시한 규범을 흔히 C99라 부른다. 이는 기술적 교정에 의하여 현재까지 3번의 수정이 있었다. 국제 C 표준은 실무 그룹 ISO/IEC JTC1/SC22/WG14에 의해 관리되고 있다.
      
      C11
      <nowiki /> 이 부분의 본문은 C11 (C 버전)입니다.
      2011년 ISO/IEC 9899:2011이 출간되었고, 간단하게 C11라고 부른다. C11이 나오기 전까지의 개발 버전을 C1X라고 부른다. 최종 개발 버전은 2011년도 4월 N1570이었다.
      
      C17
      <nowiki /> 이 부분의 본문은 C17입니다.
      2018년 ISO/IEC 9899:2018이 출간되었으며, 간단하게 C17이라고 부른다.
      
      문법
      <nowiki /> 이 부분의 본문은 C 언어 문법입니다.
      C는 C 표준에 의해 규정되는 형식 문법을 갖고 있다. 포트란 77과 같은 언어와 달리, C 소스코드는 free-form 언어로써 형식 코드에 공백을 마음대로 넣을 수 있다.
      
      연산자
      <nowiki /> 이 부분의 본문은 C와 C++ 연산자입니다.
      변수형
      <nowiki /> 이 부분의 본문은 C 언어 변수, char, int (C 프로그래밍 언어) 및 struct입니다.
      포인터
      <nowiki /> 이 부분의 본문은 포인터입니다.
      분기문
      <nowiki /> 이 부분의 본문은 분기문입니다.
      메모리 관리
      OS에서 응용 프로그램을 실행하거나, CPU의 프로그램을 실행하기 위해 여러 가지 영역으로 나누어 메모리를 할당하고 이를 메모리에 올려 실행한다.
      
      OS: 주로 저장장치에서 실행 파일을 메모리에 올려 실행한다. 따라서 프로그램에 필요한 메모리는 거의 RAM에 할당하고 실행한다.
      CPU를 사용한 장치: OS가 없이 개발자가 설정한 메모리 배치에 따라 코드를 ROM/FLASH에 생산할 때 쓰고, 전원 공급시 실행한다.
      C 언어로 개발된 프로그램은 메모리 입장에서 다음과 같은 할당 영역으로 나누어 생각할 수 있다.
      
      정적 변수: static을 이용하여 정적 변수임을 명시하고, 단 한 번만 초기화되며 프로그램이 시작할 때 생성되어 종료될 때까지 유지된다.
      동적 변수: 힙(HEAP)영역을 이용하여 할당 함수를 호출하여 변수 영역을 할당 받아 사용하고, 해제 함수에 의해 반납한다.
      자동변수: 함수나 블록({ } 이용) 안에서 선언하는 지역변수를 사용하면 스택(STACK) 영역에서 자동 할당을 받는다.
      CPU를 사용하여 개발하여 장치에 넣어 코드를 실행할 때, 힙 영역을 많이 사용하지는 않는다. 따라서 필요 없다면 메모리 공간을 할당할 필요도 없고 힙관리 프로그램 코드(함수를 개발툴에서 라이브러리 형태로 제공)도 필요하지 않는다. 만약 malloc 등의 함수를 사용하면, 힙 영역을 사용하겠다는 의미 이기 때문에 힙 영역을 개발자가 선언하여 관리 해야 한다. 이 때 힙관리 프로그램 코드는 자동으로 링크 된다. 물론 저 사양의 CPU 경우, 이 함수를 제공하지 않을 수 있는 컴파일러도 있을 수 있다.
      
      변수와 메모리 맵
      C 언어 작성된 코드는 컴파일 과정과 링크 과정을 거치면 실행 파일이 만들어진다. 변수는 여러 가지 특성이 있다.
      
      초기치를 갖는 변수
      초기치가 없는 변수
      상수 데이터
      #include <stdio.h>
      #include <stdlib.h>
      #include <string.h>
      #include <conio.h>
      
      int count = 4;
      char name[50] = "홍길동";
      char tel[256];
      
      ///////////////////////////////////
      
      int getTel(char *pstr)
      {
        static char buff[1024];
         gets(buff);
         strcpy(pstr, buff);
         return strlen(pstr);
      }
      
      int main(int argc, char **argv)
      {
        char *paddr;
      
         printf("이름= %s\n", name);
         getTel(tel);
         printf("전화 = %s\n", tel);
         paddr = (char*) malloc(1024);
         if (!paddr)
            return -1;
         {  // 블록 시작
             int scount;
             char *piaddr = paddr;
             for (scount = 1024;scount > count;scount--,piaddr++) {
               *piaddr = getch();  // getch 함수는 표준함수는 아니다.
               putchar(*piaddr);
               if (*piaddr == '\r')
                  break;
             }
             *piaddr = 0;
             printf("주소 = %s\n", paddr);
         } // 블록 끝
      
         free(paddr);
         return 0;
      }
      이 프로그램 예에서 변수 별로 분리하면 다음과 같은 특성의 변수로 나눌 수 있다.
      
      초기치 변수	int count = 4;
      char name[50] = "홍길동"[note 1];
      
      초기치 없는 변수	char tel[256];
      static char buff[1024];
      
      상수	"이름 = %s\n"
      "전화 = %s\n"
      "주소 = %s\n"
      스택
      (또는 레지스터[note 2])	char *paddr;
      char *pstr;
      int scount;
      char *piaddr;
      힙 (heap)	paddr(malloc()에서 할당된 공간)
      Notes:
      
       상수값 "홍길동"은 main() 함수가 시작되기 전, 초기과정에서 char name[]에 복사 된다. 여러개의 초기치 변수가 있을 경우 블록으로 복사 된다. 따라서 개별적으로 복사하는 기계어 코드가 존재하지 않고, 초기설정과정에서 한번에 복사 된다. 이를 구현하기 위해 컴파일러와 링커는 초기치 값만 모아서 처리 한다. 블록 내 지역변수에서 사용하는 초기치 과정은 다르다. 지역변수에서 초기치를 설정하면 그 위치에 초기치 설정하는 기계어 코드가 삽입된다.
       레지스터는 메모리가 아니다. 따라서 레지스터는 메모리 맵에 없는 내용이다. 지역변수를 스택영역에 잡을 것인가 CPU의 레지스터에 잡을 것인가는 프로그램의 복잡도와 최적화에 따라 달라진다. 함수의 기능이 간단하고 변수의 숫자가 적을 경우 레지스터로 자동 배치 될 가능성이 높아진다.
      각 특성별로 나누어 그룹을 지어 메모리에 배치 하는데, 이것을 링커가 한다. 이렇게 그룹은 나누는 것을 세그먼트(SEGMENT) 또는 섹션(SECTION)이라는 단어를 사용한다.
      
      위의 그룹은 가장 기본적인 내용만을 표시 한 것이다. CPU와 컴파일 마다 다르다. 어떤 컴파일러는 더욱 세밀히 하기도 한다. 그리고 각 세그먼트 이름도 다르다.
      
      Visual Studio의 맵 이름 예
      
      변수형태	SEGMENT
      초기치 변수	DATA
      초기치 없는 변수	BSS
      프로그램 코드	TEXT
      상수	CONST
      힙	HEAP
      스택	STACK
      컴파일마다 각 세그먼트 이름과 구조가 다르지만, 예를 들어 중요한 세그먼트 만 표시 하였다, TEXT와 CONST는 ROM/FLASH에 배치해도 되는 변하지 않는 세그먼트이므로 같은 부류이고, CPU를 설계하고 코드를 직접 쓰는 경우 ROM/FLASH을 이용한다.
      
      거의 모든 툴에서 이 맵을 파일로 만들어 준다. 물론 옵션으로 설정을 해야하는 경우도 있지만 구조를 얻을 수 있다. 함수와 변수의 위치와 이름 등을 확인할 수 있고, 각각의 세그먼트 크기 등의 데이터를 알 수 있다. 실제 CPU를 다루는 C 언어에서 이런 정보는 중요하다. 내가 사용하는 MCU의 메모리는 얼마나 사용하는지 등을 확인할 필요가 있기 때문이다.
      
      라이브러리
      C 언어 함수는 표준함수가 있고, 개발 툴에서 제공하는 함수가 있다. 여러 가지 부류가 있고 특성 별로 나누어 lib 파일로 코드를 제공하고 헤더파일로 선언을 알 수 있다.
      
      C 표준 라이브러리
      <nowiki /> 이 부분의 본문은 C 표준 라이브러리입니다.
      C 표준 라이브러리는 함수 형태와 기능이 정해져 있기 때문에 개발툴별 같다는 특징이 있다.
      
      ISO C 라이브러리 헤더
      파일명	출처	설명
      <assert.h>		assert 매크로, 논리오류 및 디버깅 시 오류 형 등 지원한다.
      <complex.h>	C99	복소수 처리용 세트.
      <ctype.h>		초기의 대-소 문자 변환 함수 제공
      <errno.h>		함수에서 발생하는 오류 형태 변환등의 오류처리.
      <fenv.h>	C99	부동소수점 환경 제어.
      <float.h>		부동소수점 특성 정의. 두 숫자 사이의 최소 차이(_EPSILON), 숫자의 최대 자리수(_DIG), 숫자의 범위의 표현(_MIN, _MAX).
      <inttypes.h>	C99	정수형 변수의 정확한 변환.
      <iso646.h>	NA1	ISO 646 문자열 처리.
      <limits.h>		정수형의 특성 정의, 정수 숫자 범위(_MIN, _MAX).
      <locale.h>		로케일( 관련 상수. 국제어 처리를 위한 적용.
      <math.h>		수학 함수.
      <setjmp.h>		setjmp 와 longjmp 매크로 선언.
      <signal.h>		다양한 예외 처리 제어.
      <stdarg.h>		아규먼트 변수 처리. va_start, va_arg, va_end 함수 등.
      <stdbool.h>	C99	논리 변수.
      <stdint.h>	C99	정수형 변수의 각종 정의/선언.
      <stddef.h>		유용한 형과 매크로 정의/선언.
      <stdio.h>		C 언어의 입출력 제공. printf 등이 포함되어 있다.
      <stdlib.h>		
      <string.h>		문자열 조작.
      <tgmath.h>	C99	수학 함수에서 일반 형 변환 관련.
      <time.h>		시간과 날짜 변환 함수.
      <wchar.h>	NA1	국제어 등의 처리를 위한 확장 문자(문자열 처리.
      <wctype.h>	NA1	확장 문자 처리.
      개발 도구
      GCC
      <nowiki /> GNU 컴파일러 모음 문서를 참고하십시오.
      유닉스 계열(리눅스)의 시스템에서 주로 사용하는 C/C++ 언어 개발 도구이다. 리눅스의 OS을 제 컴파일하거나, 각종 응용 프로그램 개발에 사용한다. 또한 X-Windows의 개발 도구로도 사용할 수 있다.
      
      전자 장치의 개발 시 임베디드 OS 포팅에서, 리눅스 커널이나 리눅스 커널 기반으로 하는 OS 커널 자체를 개발하는 도구로 사용한다. 리눅스 커널 기반 임베디드에서 실행되는 응용 프로그램 역시 gcc을 많이 사용한다.
      
      make
      <nowiki /> 이 부분의 본문은 make (소프트웨어)입니다.
      여러 파일들끼리의 의존성과 각 파일에 필요한 명령을 정의함으로써 프로그램을 컴파일할 수 있으며 최종 프로그램을 만들 수 있는 과정을 서술할 수 있는 표준적인 문법을 가지고 있고, 구조로 기술된 파일(주로 Makefile이라는 파일명)을 [make]가 해석하여 프로그램 빌드를 수행하게 된다.
      
      Cygwin
      <nowiki /> 이 부분의 본문은 시그윈입니다.
      gcc을 윈도우에서 실행할 수 있도록 재 포팅한 것이다.
      
      MinGW
      Cygwin에서 분화 된 gcc 기반 개발 라이브러리이다.
      
      이클립스
      <nowiki /> 이클립스 문서를 참고하십시오.
      이클립스는 다양한 언어와 다양한 OS에서 실행되는 IDE이다. 따라서 여러 가지 상황에서 다양하게 적용할 수 있다.
      
      Eclipse IDE for C/C++ Developers
      C/C++언어를 제공하는 IDE으로 리눅스의 경우 기존의 gcc을 사용할 수 있도록 연결 설정만 하면 된다.
      
      MinGW Archived 2006년 8월 28일 - 웨이백 머신
      윈도우에서 gcc와 연결하여 C/C++ 언어를 사용하여 프로그램을 개발 할 수 있다. MinGW는 다양한 언어를 지원하므로 다른 언어로도 이클립스와 연결하여 개발 도구로 사용할 수 있다.
      
      마이크로소프트 비주얼 스튜디오
      마이크로소프트에서 개발, 판매하는 마이크로소프트 윈도우 환경에서 작동하는 개발도구이다. 현재는 C 뿐만 아니라 C++, C# 등 다양한 언어를 지원하고 있지만 초기의 마이크로소프트 개발 도구는 C 언어로부터 출발하였다. 비주얼 스튜디오로는 윈도우 API를 이용한 GUI 프로그램, 명령 줄 인터페이스 환경으로 실행되는 Windows Console Application, 윈도우 서비스, 동적 링크 라이브러리 등의 형태로 소프트웨어를 개발할 수 있고, 최근 버전에서는 모바일 응용 소프트웨어 개발도 지원한다.
      
      비주얼 스튜디오에서 사용 가능한 소프트웨어 개발 키트와 라이브러리는 다음과 같다.
      
      C 표준 라이브러리
      표준 C에서 정의하는 라이브러리 함수를 거의 대부분 그대로 사용할 수 있다.
      
      Windows SDK
      윈도우 운영체제의 API를 사용할 수 있게 해주는 툴킷이다. 응용프로그램에서 사용 가능한 윈도우 운영체제의 기능은 Windows SDK를 통해 제공된다. 초기에는 C가 기본 언어였으나, 최근에는 C#, C++ 등의 언어 툴킷도 제공한다. 예전에는 Win32 SDK라고 불리었다.
      
      MFC
      <nowiki /> 이 부분의 본문은 마이크로소프트 파운데이션 클래스 라이브러리입니다.
      윈도우 개발에 필요한 Windows API를 클래스로 래핑한 C++ 라이브러리이다.
      
      DirectX
      윈도우에서 주로 게임 등을 개발할 때 사용하는 툴킷이다. 고속의 화면 제어, 음성지원, 3D 등을 지원한다.
      
      
      CODEBLOKES
      
      그럭저럭한 툴
      
      디버깅
      보통 소프트웨어 개발에서 디버깅의 가장 일반적인 방법은 두가지이다.
      
      IDE를 통해 소스 수준에서 디버깅 한다. 일명 'BREAK POINT'를 설정하면 그 위치에서 멈추고 해당 상황을 파악할 수 있다. 가장 중요한 파악 대상이 변수의 값으로 표시 화면에 해당 변수의 형과 맞게 변수의 값을 표시 한다. 또한 줄단위로 실행하기, 함수로 들어가기와 나오기 등 IDE에 따라 구성이 다양하다.
      내부 변수나 기타 상황을 printf 형태의 함수를 UART, 네트워크, USB 등과 연결하여 출력함으로써 프로그램 상황을 표시 할 수 있다. 보통 IDE처럼 다양한 구성이 불가능 할 때 많이 사용한다.
      리눅스 커널의 경우 printfk 함수로 출력하면 정해진 출력 메시지 파일태로 표시할 수 있다.
      MCU와 같은 전자장치의 개발에서 개인용 컴퓨터처럼 성능이 좋은 IDE을 만들기 쉽지 않다. 따라서 저 성능의 IDE을 사용하거나 UART등으로 상황을 출력해서 디버깅 하는 방법을 사용할 수 있다. 구성이 간단해서 개발 소스에 printf 형의 메시지 출력을 추가하면 된다. 개발자가 직접 해야하는 것이 번거롭다.
      GDB
      <nowiki /> 이 부분의 본문은 GNU 디버거입니다.
      GCC을 기반으로 하는 디버깅 도구이다. 따라서 유닉스 계열에서 가장 일반적으로 실행된다.
      
      응용 프로그램 디버깅
      GCC 옵션을 디버깅이 되도록 설정하면 디버깅 테이블을 만든다. gdb 실행 중에 이것을 사용한다. GDB을 실행하여 응용 프로그램을 실행하면서 break, 변수, 함수 등의 디버깅을 할 수 있다.
      
      원격 디버깅
      GCC에서 gdb는 서버 구조를 사용할 수 있다. gdb-server을 설치하면 네트워크를 통해 디버깅 환경을 구성할 수 있다. 예를 들어 임베디드 개발 시 리눅스 커널을 포팅하고, 해당 리눅스 시스템에 gdb-server를 설치하면 다른 환경에서 이를 통해 응용 프로그램을 디버깅 할 수 있다. 임베디드의 많은 경우 자신의 시스템에서는 디버깅이 만만치 않다. 따라서 원격으로 gdb의 실행 결과를 전송 할 수 있고 이 정보를 바탕으로 이클립스와 같은 IDE와 연동할 수 있다. 보통 리눅스 기반의 임베디드 개발 환경은 이클립스 C++를 사용할 수 있는데, 이것과 결합할 수 있다.
      
      커널 디버깅
      원격 디버깅 모드는 리눅스 커널에 사용되는 소스 수준의 디버거인 KGDB에서도 사용된다. KGDB를 사용하면 커널 개발자는 일반 응용 프로그램과 마찬가지로 커널을 디버깅할 수 있다.
      
      IDE 디버깅
      비주얼 스튜디오나 이클립스 등의 도구 들은 기본적으로 디버깅 방법을 제시한다. 이클립스 디버깅은 GDB와 연동해서 구성할 수 있다.
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      C
      B
      C99
      C11
      C 언어의 문법
      C 언어 변수
      C 언어 포인터
      C++
      오브젝티브-C`,
    },
    {
      id: 21,
      title: "C++",
      contents: `C++는 AT&T 벨 연구소의 비야네 스트롭스트룹이 C언어 기반으로 1985년에 발표하여 발전한 프로그래밍 언어이다.

      역사
      C++ 표준
      연도	C++ 표준	비공식 명칭
      1998	ISO/IEC 14882:1998[1]	C++98
      2003	ISO/IEC 14882:2003[2]	C++03
      2011	ISO/IEC 14882:2011[3]	C++11, C++0x
      2014	ISO/IEC 14882:2014[4]	C++14, C++1y
      2017	ISO/IEC 14882:2017[5]	C++17, C++1z
      2020	ISO/IEC 14882:2020[6]	C++20, C++2a
      1979년, 덴마크의 컴퓨터 과학자 비야네 스트롭스트룹은 C++의 선구자격 언어인 "C with Classes" 작업에 착수하였다.[7] 새로운 언어를 만들려는 의의는 박사 논문을 위한 스트롭스트룹의 프로그래밍 경험에서 비롯되었다.
      
      처음에 스트롭스트룹의 "C with Classes"는 C 컴파일러(Cpre)에 클래스, 상속 클래스, 스트롱 타이핑, 인라인 확장, 기본 인수를 포함한 여러 기능들을 추가하였다.[8]
      
      1983년, "C with Classes"라는 이름은 가상 함수, 함수 이름, 연산자 오버로딩, 참조, 제약조건, type-safe free-store 메모리 할당 (new/delete), 개선된 자료형 검사, BCPL 스타일의 1줄 코멘트(//)를 포함한 새로운 기능들을 추가하면서 "C++"로 변경되었다.
      
      1985년 C++ 프로그래밍 언어 제1판이 출시되었으며 당시 공식표준이 없었기 때문에 이 언어의 절대적인 참조 문헌이 되었다.[9] 최초의 C++ 상용 구현체는 같은 해 10월에 출시되었다.[7]
      
      특징
      C 언어에 객체지향 프로그래밍을 지원하기 위한 내용이 덧붙여진 것이라고 할 수도 있지만[10], 애초부터 객체지향을 염두에 두고 만들어진 언어와는 다르게, 단지 더 좋은 C 언어로서 수속형 언어로 취급하기도 한다. 초기의 C++은 C 위에 놓인 트랜스레이터로 구현되었다. 즉, C++ 프로그램을 일단 C 프로그램으로 변환하고 나서 C 컴파일러로 컴파일하는 식이었고 따라서 C 언어에 대해 상위 호환성을 갖는 언어였다.
      
      그 후, C 언어의 표준 규격이 바뀔 때 const 수식 등 C++의 기능이 C 언어에 받아들이기도 했다. 현재 C 언어와 C++와의 사이에는 엄격한 호환성은 없다. 특히 C99의 출현으로 C 언어와의 호환성은 깨져 버렸다. 따라서 C99 이후로 C++은 C의 수퍼셋(superset)이 아니다. 그러나, C++17 표준안에서는 다시 C언어가 C++의 진부분집합이 될 것이 확실해 보인다. 현재 C와 C++가 명확한 구별 없이 혼재되어 사용되는 컴파일러가 대부분이지만 C99 이후의 문법을 C++ 컴파일러에서 컴파일할 경우 오류가 발생할 수 있다.
      
      다음과 같은 다양한 기능을 가지고 있어 C++ 언어의 표준 규격은 몹시 복잡하다. C++ 표준의 모든 사항을 완전하게 지원하는 컴파일러는 현재 손꼽을 정도이다.
      
      다중 상속
      템플릿
      연산자 오버로드
      예외 처리
      실행시 형 식별
      덧붙여 예부터 전해 내려온 절차적인 성격도 그대로 남아 "만능" 설계로, 유연함과 강력함은 다른 언어에 비할 바가 아니지만, 복잡한 언어가 되고 말았다. 이런 점 때문에 보다 객체지향성을 강화하여, 만능설계를 지향하기보다는 단순한 설계를 목표로 한 새로운 언어들인 자바, C#, D 언어 등이 나오기도 했다.
      
      캡슐화
      캡슐화는 2가지 요소를 만족하도록 언어적으로 구현 되어야 한다.
      
      데이터와 메서드 결합
      C++에서는 객체의 저장공간의 위치(this로 표현되는 객체의 데이터 위치 주소값)를 함수에 넘김으로써 데이터와 메서드를 결합한다. this는 객체의 위치 주소값인 포인터이다.
      
      외부에 데이터나 메서드를 은닉
      객체 지향 프로그래밍에서 작성된 프로그램 코드는 재사용이 중요한 요소이다. 재사용하려면 다른 개발자가 사용할 때, 필요한 사용방법만 알면된다. 클래스 내면 깊숙히 알 필요가 없는 경우가 많다. 따라서 객체를 설계할 때, 경우에 따라 멤버 변수나 멤버 함수를 다 알릴 필요가 없다. 어떤 요소들은 내부에서 사용하고 비공개로 설정할 필요가 있다. 해당 객체를 사용하거나 상속해서 사용할 때, 필요한 요소만을 공개하고 API을 작성하여 공개하면 된다. 이런 비공개의 방법으로 은닉을 설정하고 캡슐화의 한요소가 된다.
      
      키워드 3개가 있다. private, protected, public을 사용해서 접근을 제한할 수 있다.
      
      class MyObject {
      public:
           MyObject() { }
      
           int getData();  // 은닉된 데이터는 메서드를 사용하여 인터페이스로 쓸 수 있다.
      
      private: // 이 지정자는 자기 클래스에서만 액세스를 한정한다. 은닉하는 방법으로 사용.
           int m_data;
      };
      
      int MyObject::getData()
      {
         return this->m_data; // this가 자동으로 넘어온다.
      }
      여기서 데이터와 메서드 결합은 멤버함수를 구성할 때 this라는 포인터로 상징되는 것을 개발자 코드내에 코딩없이도 자동으로 넘겨 주어 해당 클래스 내의 멤버변수들을 사용하게 하였다. 이렇게 언어적으로 결합한다.
      
      this는 자동으로 객체의 공간위치값이 메모리의 주소값이다. 이것을 포인터로 사용하였다. 이것으로 결국 어떤 객체인지를 구별하는 수단으로 사용하여, 데이터와 메서드를 결합한다. MyObject::가 붙는 클래스의 멤버함수는 실행할 때 자동으로 모두 this가 넘어간다. static 메서드는 this가 제외된다.
      
      this가 멤버 함수에 넘어가는 방법으로 CPU의 레지스터를 사용할 수도 있다. 멤버 함수에서 멤버 변수를 사용할 때 레지스터에 저장된 객체의 위치 주소값으로 하여 내부 멤버변수의 상대주소값과 합하여 위치값을 다시 설정하고 액세스 하면 된다. 이것은 마치 struct의 시작주소와 내부변수의 상대적 위치값의 합으로 표현하는 주소체계와 유사하다.
      
      예제
      Hello world 프로그램
      C++ 표준 라이브러리 스트림 기능을 사용하여 표준 출력을 통해 Hello, world!를 출력한다.
      
      # include <iostream> //iostream이라는 헤더를 가져온다
      
      using namespace std; //namespace의 std 모듈을 사용한다
      
      int main() { //메인메소드의 시작지점이다.
      
          cout << "Hello, world!" << endl; //"Hello, World!" 콘솔로 출력한다.
      
          return 0; //0을 리턴해 프로그램을 확실히 종료시킨다.
      }//메인메소드를 끝낸다
      C++20의 모듈 기능을 이용하면 다음과 같이 쓸 수 있다.
      
      import std.core;
      
      using namespace std;
      
      int main() {
      
          cout << "Hello, world!" << endl;
      
          return 0;
      }
      가급적이면 void main을 사용하지 말자. 컴퓨터는 프로그램이 0이 아닌 수를 반환하면
      
      그 프로그램이 제대로 종료되었다 생각하지 않는다. 즉 int main으로 숫자 0을 리턴하여
      
      잘 종료되었다는 걸 컴퓨터에게 알려주자.
      
      객체의 생성과 소멸
      객체를 구현하기 위해 클래스의 선언이 필요하다. 구조적인 설정을 하고 생성하면 된다.
      
      객체의 선언
      객체의 모양은 클래스를 사용하여 형을 선언하여 프로그램 한다. C언어에서 전역변수, 지역변수가 있듯이 객체도 선언 위치에 따라 생성과 소멸이 다르다.
      
      객체 만들기 :
      
      클래스로 객체의 구조를 만든다. 멤버 변수와 멤버 함수로 구성된다.
      정적 또는 동적으로 객체를 생성한다.
      전역 정적 객체 : main() 함수 전에 객체의 메모리 공간을 생성하고 생성자가 자동 실행된다. 전역형은 메모리 맵에서 할당된 특정영역을 사용한다. 따라서 응용 프로그램이 시작하기 위해 운영 체제로부터 할당 받아 사용한다.
      지역 정적 객체 : 객체가 선언된 시점에서 객체의 메모리 공간을 생성하고 생성자가 자동 실행된다. 지역변수처럼 주로 스택에 할당된다.
      동적 객체 : new에 의해 힙영역에 객체의 메모리 공간을 생성하고 생성자가 자동 실행된다.
      객체 소멸 :
      
      전역 정적 객체 : main() 함수 return후 소멸된다. 응용 프로그램의 종료와 동시에 소멸된다.
      지역 정적 객체 : 함수 블럭 또는 객체가 생성된 임의의 자기 블럭이 끝나면 소멸된다.
      동적 객체 : delete에 의해 소멸된다.
      접근자
      클래스는 캡슐화가 가능하다. 따라서 객체를 설계할 때는 특정 멤버변수나 멤버함수를 외부에서 접근을 제한할 필요가 있다.
      
      접근 제어 키워드 3가지:
      
      private : 자기 클래스에서만 접근을 허용한다.
      public : 모두 접근을 허용한다.
      protected : 자기 클래스와 상속을 받은 자식 클래스에서만 접근을 허용한다.
      객체의 생성
      C언어에서는 전역변수와 지역변수 그리고 동적할당에 의한 데이터 저장공간을 만들 수 있다. 마찬가지로 C++에서도 전역변수로 객체를 생성할 수도 있고 지역변수로 생성하는 것도 가능하다. 또한 new를 통해 동적으로 객체를 생성 시킬 수 있다.
      
      정적 할당 객체
      C++에서 변수를 잡듯이 객체도 선언을 통해 이루어진다. C에서 전역변수와 지역변수로 나누어는 것과 같이, 객체 역시 같은 방식으로 전역 또는 지역 객체로 선언할 수 있다.
      
      전역 정적 객체는 main() 함수가 실행되기 전 저장공간이 생성되고, 생성자가 호출된다. 객체가 생성되면 메모리에 데이터 저장공간이 생기고 바로 생성자가 호출된다. 따라서 전역 정적 객체 생성자의 호출은 main함수보다 먼저 이루어진다.
      
      동적 할당 객체
      new에 의해 생성 되고, delete에 의해 삭제된다. new로 생성 되면, new 실행 시점에서 객체의 저장공간인 메모리를 확보하고 생성자가 자동실행된다. 동적객체는 힙영역에 존재하고 포인터를 넘겨 받아서 객체 포인터 변수에 주소값을 저장하고 처리한다.
      
      'new'의 코딩은 함수에 넣을 수 밖에 없으므로 main 함수 시작 이후에야 가능하다.
      
      이미 설정된 메모리 공간을 이용하여 객체 정의하기
      C/C++은 포인터를 사용한다. 이것은 객체의 크기만 확보되면 객체를 사용하는데 아무 문제가 없다. 따라서 이미 설정된 변수를 포인터를 이용하여 객체화 해서 사용할 수 있다.
      
      #include <iostream>
      
      typedef struct MsgBuff {
          MsgBuff *link;
          int  szpkg;
          int  szdata;
          void *data;
      } MsgBuff;
      
      class A {
      public:
          A() { num = 0; }
          int num;
      };
      
      char gbuff[1024];
      
      int main(int argc, char* argv[])
      {
          MsgBuff *pmsg = (MsgBuff*) gbuff;
          int szpkg = sizeof(A)+sizeof(pmsg->link)+sizeof(int)*2;
          pmsg->link = NULL;
          pmsg->szdata = sizeof(A);
          pmsg->szpkg = szpkg;
      
          A *pa = (A*) &pmsg->data;
          pa->num = 10;
          std::cout << pa->num << std::endl;
      
          return 0;
      }
      블럭에서의 정적 클래스 생성과 소멸
      #include <iostream>
      using namespace std;
      
      class A {
      public:
         A() { num = 0; }
         A(int n) : num(n) { cout << "생성자 호출 : " << this << endl;  }
         ~A() { cout<< "소멸자 호출 : " << this << endl; }
         int getNum() { return num; }
      
      private:
         int num;
      };
      
      int main()
      {
         int num;
      
         cout << "블럭 시작 합니다." << endl;
         {  // 블럭 시작하면 지금부터 선언되는 변수나 클래스는 블럭이 끝나면 사라진다.
            A a(10);
      
            num = a.getNum();
            cout << "블럭 안에서 a.getNum() = " << a.getNum() << endl;
      
         } // 블럭이 끝나면 객체 a는 소멸됨. 소멸자가 호출된다.
         cout << "블럭 끝났습니다. num = " << num << endl;
         return 0;
      }
      실행결과:
      
      블럭 시작 합니다.
      생성자 호출 : 0039FCD0
      블럭 안에서 a.getNum() = 10
      소멸자 호출 : 0039FCD0
      블럭 끝났습니다. num = 10
      모든 함수는 블럭을 포함하므로 함수내에서 생성된 정적객체는 함수의 블럭이 끝나면 소멸자가 호출되고 객체의 저장공간은 사라진다. 위의 예처럼 임의의 블럭에서 생성된 정적객체 역시 자기의 블럭이 끝나면 소멸자가 호출되고 사라진다.
      
      클래스 변수 선언 시, 클래스 간 교착상태
      클래스 내에서 멤버변수로 다른 클래스를 사용할 수 있다. 정적 멤버변수와 포인터가 가능하다. 그러나 2개의 클래스가 서로 정적인 객체를 선언하면 교착상태로 빠져 객체의 크기를 결정할 수 없다. 따라서 불가능해 진다.
      
      교착상태	한쪽의 크기 결정
      class B;
      class A {
         int num;
         B b;
      };
      class B {
         int num;
         A a;
      };
      class B;
      class A {
         int num;
         B *b;
      };
      class B {
         int num;
         A a;
      };
      이 경우 A 클래스는 B 클래스를 멤버변수로 잡았다. 이렇게 하려면 우선 B 클래스의 멤버변수들의 데이터 저장공간의 크기가 결정되어야 한다. 그러나 B 클래스에서 다시 A 클래스를 선언함으로써 크기를 결정할 수 없는 상태가 된다. 따라서 이런경우는 불가능 하다. 결국 한쪽에서 포인터를 사용하여 먼저 크기를 확정해 주어야 한다.
      위와 같은 경우 A클래스의 객체 저장공간의 크기는 결정할 수 있다. 모든 포인터는 CPU의 메모리 주소체계가 이미 결정되어 있으므로 크기 계산이 가능하고 각 멤버변수의 주소위치도 결정할 수 있다. A클래스가 결정되었으므로 이제 B클래스도 결정할 수 있다.
      
      클래스 내에서 클래스 변수 선언 시 교착상태
      
      재귀적 선언	변수의 크기 결정
      class A {
         int num;
         A a;
      };
      class A {
         int num;
         A *a;
      };
      마찬가지로 저장공간의 크기를 결정할 수가 없다.	포인터 변수이므로 크기를 결정할 수 있어서 가능하다.
      객체의 예
      /// 파일 : MyObject.h ////////////////////////////////////
      
      class MyObject { // 클래스의 시작
      public:
         MyObject();   // 생성자1
         MyObject(int age, char *name);  // 생성자2 : 생성자는 여러가지가 가능하다.
         virtual ~MyObject();  // 소멸자
      
         // 멤버변수 age, name, fdyn가 privated이므로 다른 객체에서 접근이 불가능 하다.
         // 따라서 멤버함수로 해결한다. setAge, getAge,setName,getName
      
         void setAge(int age) { this->age = age; }  // 함수 본체를 클래스 내에 코딩할 수 있다.
                          // 모든 함수를 헤더의 클래스 안에 코딩하면 클래스 전체를 파악하는데 불편할 수 있다.
                          // 그리고 파일을 cpp와 h로 나누는 의미가 훼손될 수 있다.
         int getAge() { return age; }
      
         void setName(char *n, int opt = 0);  // 만약 opt을 사용하지 호출하면 자동으로 0을 설정한다.
         char* getName();
      
         static int counter;
      
      private:
         int age;
         char *name;
         int  fdynm;  // name 변수의 메모리 공간을 new (malloc())로 만들었는지를 설정
      };
      
      /// 파일 : MyObject.cpp //////////////////////////////////
      #include <iostream>
      #include "MyObject.h"
      using namespace std;
      
      MyObject::MyObject() // 생성자1
      {
         age = 0;
         name = NULL;
         fdynm = 0;
      
         cout << "+생성자1 MyObject() : " << this << endl;
      }
      
      MyObject::MyObject(int age, char *name) // 생성자2
      {
         this->age = age;
         this->name = name;
      
         cout << "+생성자2 MyObject("<< age
       <<","<< name << ") : " << this << endl;
      }
      
      MyObject::~MyObject() // 소멸자
      {
        cout << "-소멸자 MyObject("<< name <<") : " << this << endl;
      
        if (fdynm) { // name을 저장할 공간을 new로 만들었다면 삭제 한다.
          cout << " delete name = " << name << endl;
          delete [] name;
          name = NULL;
        }
      }
      
      int MyObject::counter = 0; // static은 각 객체마다 저장공간이 확보 되지 않는다.
                                  // 전체에서 단 하나의 변수 공간 만이 존재한다.
                                  // public이므로 어디에서나 접근이 가능하다.
      
      char* MyObject::getName() { return name; }
      
      void MyObject::setName(char *n, int opt)
      {
        if (fdynm) delete [] name;
        name = n;
        fdynm = opt;
      }
      
      /// 파일 : main.cpp //////////////////////////////////
      #include <iostream>
      #include "MyObject.h"
      using namespace std;
      
      //// 전역변수 //////////////////
      
      MyObject gMe(19, "홍길동"); // 객체를 생성하고, 생성자2을 호출 한다.
      
      int main(int argc, char* argv[])
      {
        cout << "main() 시작.\n";
      
        MyObject *pm = &gMe;
      
        MyObject::counter++;
        cout << MyObject::counter << " " << pm->getName() << " / "
       << pm->getAge() << endl;
      
        MyObject kim; // 객체를 생성하고, 생성자1을 호출 한다.
        pm = &kim;
        char *pname = new char[50];
        strcpy(pname, "이순신");
        pm->setName(pname, 1);
        pm->setAge(33);
      
        pm->counter++;
        cout << MyObject::counter << " " << pm->getName() << " / "
       << pm->getAge() << endl;
      
        pm = new MyObject(); // 객체를 동적으로 만든다. 생성자1 사용.
        pm->setName("세종대왕");
        pm->setAge(33);
      
        MyObject::counter++;
        cout << MyObject::counter << " " << pm->getName() << " / "
       << pm->getAge() << endl;
        delete pm;
      
        cout << "main() 끝.\n";
      
        return 0;
      }
      </source >
      실행결과 예:
       +생성자2 MyObject(19,홍길동) : 00FDD174
       main() 시작.
       1 홍길동 / 19
       +생성자1 MyObject() : 0031F9C4
       2 이순신 / 33
       +생성자1 MyObject() : 004D4948
       3 세종대왕 / 33
       -소멸자 MyObject(세종대왕) : 004D4948
       main() 끝.
       -소멸자 MyObject(이순신) : 0031F9C4
          delete name = 이순신
       -소멸자 MyObject(홍길동) : 00FDD174
      
      === 객체의 메모리 구조 ===
      
      객체는 클래스에 의해 규정된 구조에 따라 메모리 공간을 확보하고 메모리에 [[액세스 (마이크로프로세서)|액세스]] 함으로써 데이터 처리가 된다. 이 구조는 기본적으로 struct와 별로 다를 바가 없다. 멤버변수만을 모아 순서대로 나열하여 특정 크기의 메모리를 확보하면 된다. struct에 C++에 필요한 몇가지 추가될 수 있다.
      
      위의 예 프로그램의 객체구조를 알기 위해 다음과 같이 프로그램 하면:
      
      <syntaxhighlight lang="cpp">
      #include <iostream>
      #include <stdio.h>
      #include "MyObject.h"
      using namespace std;
      
      MyObject hong(19, "홍길동");
      
      int main(int argc, char* argv[])
      {
        MyObject *pm = &hong;
      
        printf("sizeof(MyObject)=%d\n", sizeof(MyObject) );
        printf("&pm=0x%08X, sizeof(pm)=%d\n", &pm, sizeof(pm) );
        printf("pm=0x%08X\n", pm );
      
        printf("&hong=0x%08X, sizeof(hong)=%d\n", &hong, sizeof(hong) );
        printf("&counter=0x%08X, value=%d\n", &MyObject::counter, MyObject::counter);
        printf("&age=0x%08X, value=%d\n", &hong.age, hong.age );
        printf("&name=0x%08X, value=%s\n", &hong.name, hong.name );
        printf("&fdynm=0x%08X, value=%d\n", &hong.fdynm, hong.fdynm );
      
        MyObject lee(23, "이순신");
        printf("&lee=0x%08X\n", &lee);
      
              return 0;
      }
      실행결과 (x86, 32비트) 예 :
      
      +생성자2 MyObject(19,홍길동) : 00ACC170
      sizeof(MyObject)=16
      &pm=0x003EFBA8, sizeof(pm)=4
      pm=0x00ACC170
      &hong=0x00ACC170, sizeof(hong)=16
      &counter=0x00ACC184, value=0
      &age=0x00ACC174, value=19
      &name=0x00ACC178, value=홍길동
      &fdynm=0x00ACC17C, value=0
      +생성자2 MyObject(23,이순신) : 003EFB90
      &lee=0x003EFB90
      -소멸자 MyObject(이순신) : 003EFB90
      -소멸자 MyObject(홍길동) : 00ACC170
      
      x86 32비트 환경에서 객체 구조 예. virtual사용한 경우.
      소멸자에서 virtual을 붙이는 가장 중요한 이유는 상속과 관련하여 소멸자를 정확히 실행하기 위해서이다. 소멸자를 호출할 때, 이 테이블을 보고 호출한다.
      
      'static int MyObject::counter' 변수는 객체와 분리하여 한개의 전역변수로 처리된다. 따라서 이것은 객체의 메모리 크기에 들어가지 않는다. sizeof연산자에 의해 바이트수를 얻은면 16바이트가 된다. 여러개의 같은 클래스의 객체가 존재해도 이 변수는 하나만 존재할 뿐이다. 그리고 정적으로 처리되므로 전역변수만 가능하다.
      
      이제 virtual을 삭제하고 객체를 만들면 멤버변수들로만 구성된 구조를 갖는다.
      
      실행결과 (x86, 32비트) 예 :
      
      +생성자2 MyObject(19,홍길동) : 0083C138
      sizeof(MyObject)=12
      &pm=0x003CFBFC, sizeof(pm)=4
      pm=0x0083C138
      &hong=0x0083C138, sizeof(hong)=12
      &counter=0x0083C148, value=0
      &age=0x0083C138, value=19
      &name=0x0083C13C, value=홍길동
      &fdynm=0x0083C140, value=0
      +생성자2 MyObject(23,이순신) : 003CFBE8
      &lee=003CFBE8
      -소멸자 MyObject(이순신) : 003CFBE8
      -소멸자 MyObject(홍길동) : 0083C138
      
      x86 32비트 환경에서 객체 구조 예. virtual이 없는 경우.
      이것은 다음 struct와 메모리 구조가 같다.
      
      /// 파일 : MyStruct.h ///
      #ifndef MYSTRUCT_H
      #define MYSTRUCT_H
      
      typedef struct {
         static int counter;
      
         int age;
         char *name;
         int  fdynm;
      } MyStruct;
      
      void setMyStruct(MyStruct* pthis, int age, char *name, int opt = 0);
      
      #endif
      
      // 파일 : MyStruct.cpp /////////
      #include <stdio.h>
      #include "MyStruct.h"
      
      int MyStruct::counter = 0;
      
      void setMyStruct(MyStruct* pthis, int age, char *name, int opt)
      {
         pthis->age = age;
         pthis->name = name;
         if (pthis->fdynm) delete [] pthis->name;
         pthis->fdynm = 0;
      }
      
      // 파일 : main.cpp ////////
      #include <stdio.h>
      #include "MyStruct.h"
      
      int main()
      {
         MyStruct stdata;
         stdata.fdynm = 0;
         setMyStruct(&stdata, 11, "Song");
      
         printf("&stdata=0x%08X, sizeof(stdata)=%d\n", &stdata, sizeof(stdata) );
         printf("&counter=0x%08X, value=%d\n", &MyStruct::counter, MyStruct::counter);
         printf("&age=0x%08X, value=%d\n", &stdata.age, stdata.age );
         printf("&name=0x%08X, value=%s\n", &stdata.name, stdata.name );
         printf("&fdynm=0x%08X, value=%d\n", &stdata.fdynm, stdata.fdynm );
         // ...
      }
      실행결과 (x86, 32비트) 예 :
      
      &stdata=0x0036FBC8, sizeof(stdata)=12
      &counter=0x011EC14C, value=0
      &age=0x0036FBC8, value=11
      &name=0x0036FBCC, value=Song
      &fdynm=0x0036FBD0, value=0
      
      x86 32비트 환경에서 C언어의 struct 메모리 구조 예.
      멤버 변수
      클래스 내부의 변수를 말 한다. 클래스의 속성(attribute)이다. 기본 자료형과 다른 클래스 들도 정의가 가능하다.
      
      멤버함수는 프로그램 코드이므로 결국 기계어 코드 묶음에 존재한다. 멤버함수가 실행될 때, 객체의 변수들로 구성된 메모리 구조체의 시작 주소값으로 전달되어 조작된다.
      
      객체 공간의 액세스 시, 객체영역 초과 액세스 문제
      C에서도 마찬가지이지만, C++는 단지 메모리의 주소값을 이용하여 액세스하는 단순한 방법을 사용한다. 따라서 배열등에서 정의된 크기보다 큰 인덱스로 쓰기하면, 쓰기 자체에는 아무 문제없이 써진다. 그러나 변수가 차지하고 있는 공간을 넘어서는 문제는 C++에서도 그대로 적용된다. 자바와는 달리 어떤 보호책이 없다.
      
      #include <iostream>
      
      class A {
      public:
         A() { num = 0; }
         A(int n) { num = n; }
      
         int num;
      };
      
      int main(int argc, char* argv[])
      {
          A a(10);
          char buff[4];
          char *pstr = buff;
      
          std::cout << "num=" << a.num << std::endl;
          printf("&a=0x%08X\n", &a);
          printf("buff=0x%08X\n", buff);
      
          for (int cnt = 0;cnt < 16;cnt++)
        *pstr++ = cnt;
      
          std::cout << "num=" <<  a.num << std::endl;
      
          return 0;
      }
      실행 결과 예 (x86 32비트 CPU, 마이크로소프트 비주얼스튜디오):[note 1]
      
      num=10
      &a=0x0027F848
      buff=0x0027F83C
      num=252579084
      여기에서 10이어야 하는 값이 252579084로 바뀌어 졌다. 이것은 16바이트를 쓰면서 buff영역을 넘어서기 때문이다. buff와 객체 a와는
      
      0x0027F848-0x0027F83C=0xC=12
      의 공간차이가 난다. 따라서 12바이트 이상 쓰기 하면 a 영역의 값이 변한다.
      
      
      Notes:
      
       실행결과에서 메모리 배치는 CPU와 컴파일러/링커에 따라 다를 수 있다. 3개의 변수 위치는 컴파일러 마다 조금씩 차이가 있을 수 있다.
      멤버 함수
      클래스의 행위(behavior)를 정의한 것으로 기능적으로 설정된 프로그램 묶음이다.
      
      this
      모든 멤버함수는 멤버변수들로 구성된 구조적 저장공간이 필요하다. 각각의 다른 객체는 다른 메모리 공간에 존재 한다. 따라서 여러개의 객체를 구별한 포인터 변수가 필요하다. this는 객체의 위치를 정의하는 포인터 변수라고 생각하면 된다.
      
      어느 객체에 조작을 할것인가를 결정하는 포인터이다. 'this'는 클래스 내에 변수 선언이 필요없고 이미 정의된 키워드이다.
      
      캡슐화의 방법으로 멤버함수는 this을 통해 멤버변수와 묶는 방법으로 사용한다.
      
      다음 예의 구조체와 클래스에서
      
      struct MyStruct {
         int opt;
         int age;
         char *name;
      };
      
      class MyObject
      {
      public:
         MyObject() { opt = age = 0; name = NULL;}
         void MyObject::setMyObject(int age, char *name, int opt = 0);
      
      private:
         int opt;
         int age;
         char *name;
      };
      
      void setMyStruct(MyStruct* pthis, int age, char *name, int opt/* = 0*/)
      {
         pthis->opt = opt;
         pthis->age = age;
         pthis->name = name;
      }
      
      void MyObject::setMyObject(int age, char *name, int opt/* = 0*/)
      {
         this->opt = opt;
         this->age = age;
         this->name = name;
      }
      위의 예에서 C언어의 struct는 구조체 내의 변수들을 묶어서 메모리에 할당한다.
      
      C 언어의 struct : void setMyStruct(MyStruct* pthis, int age, char *name, int opt = 0);
      C++ 객체의 멤버함수 : void MyObject::setMyObject(int age, char *name, int opt = 0);
      위의 2개의 차이는 'MyObject::'을 붙이면 this 포인터가 자동으로 들어간다. 이를 통해 멤버함수를 클래스와 통합한다. 그러나 C언어의 함수는 어떤 변수의 구조체와 연결이 없다. 필요하면 포인터나 변수를 인수를 통해 넘길 뿐이다. 그러나 C++에서는 this는 반드시 포함 시키는 차이가 있다. static 멤버함수는 this가 넘어가는 것은 제외된다.
      
      static 멤버 함수
      this가 객체의 위치 주소값을 취급하는 자동 포인터로써 멤버함수가 호출되면 자동으로 따라 다닌다. 이말은 이미 객체가 존재 한다는 것이다. 그러나 static을 사용하면 특정 객체의 this을 사용하지 않는다. 객체가 이미 존재하는 것은 상관없이 이미 존재하는 객체의 포인터 값을 모른다. 따라서 호출 할때, 특정 객체가 미리 생성되지 않아도 된다. 이미 생성되었다면 오히려 인수로 넘겨 주어야 한다.
      
      class A {
      public:
         A(int n) { num = n; }
         int num;
         int add(int n2) { return (num += n2); }
      
         static int add(A *pa, int n2);
      };
      
      int A::add(A *pa, int n2)
      {
          //num += n2;  // 오류 : this을 사용할 수 없다. 객체의 포인터가 넘어오지 않는다.
       // error C2597: illegal reference to non-static member 'A::num'
          pa->num += n2;
          return pa->num;
      }
      
      int main()
      {
          A a(10);
          int r = A::add(&a, 20);     // 결과 30
          std::cout << r << std::endl;
      
          r = a.add(&a, 10);           // 결과 40
          std::cout << r << std::endl;
      
          return 0;
      }
      위의 프로그램 예제 코드 처럼, 객체가 없는 상태에서 실행되는 것이 static 멤버함수이기 때문에 객체의 멤버변수를 사용하지 않아도 된다. 클래스 이름으로 호출하면 되고 설령 이미 존재하는 객체의 멤버변수로 하더라고 this 가 넘어가지 않으므로 별 차이가 없다. 캡슐화 되지 않는 C 언어의 함수와 별 차이가 없다. C 언어의 함수와의 차이는 단지 '어느 클래스에 속하는냐'만의 의미만 갖는다.
      
      struct 사용 함수, 객체 멤버변수, static 멤버함수 비교
      struct 사용 함수	객체 멤버변수	static 멤버함수
      struct MyStruct {
      
         int num;
      
      };
      
      
      
      
      int add(struct MyStruct *pthis, int n)
      { return (pthis->num += n); }
      
      // 사용하기
         struct MyStruct st = { 10 };
         int num;
         num = add(&st, 1);
      class MyObject {
      public:
         int num;
      
         MyObject(int n) : num(n) { }
         int add(int n);
      
      };
      
      int MyObject::add(int n)
      {  return (this->num += n); }
      
      // 사용하기
         MyObject obj(20);
         int num;
         num = obj.add(1);
      class MyObject {
      public:
         int num;
      
         MyObject(int n) : num(n) { }
         static int add( MyObject *pthis, int n);
         static int add(int n1,int n2){return n1+n2;}
      };
      
      int MyObject::add(MyObject *pthis, int n)
      { return (pthis->num += n); }
      
      // 사용하기
         MyObject obj(20);
         int num = MyObject::add(&obj, 1);
         num = obj.add(&obj, 1);
         num = MyObject::add(1, 2);
      struct(구조체) 와 class(클래스)는 동일
      흔히 구조체는 클래스 이전에 선언되고 주로 여러종류의 기억공간을 선언하기 위한 형태로만 보는 경우가 일반적인데, 이는 틀린 생각이다. 구조체 역시 클래스와 동일하게 생성자와 소멸자를 지정할 수 있고, 코딩이 가능하며 내부호출과 캡슐화가 가능하다. 따라서, 하나의 물체(Object)를 하나의 구조체(struct) 로 선언하고 사용할 수 있다. 따라서, 구조체 내에서도 모든 함수와 명령을 클래스와 동일하게 사용 가능하다. 다만, 멤버에 대해 접근 지정자를 써 주지 않는 경우 구조체는 public이 되고, 클래스는 private이 된다는 차이가 있다.
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      C++
        위키책에 이 문서와
      관련된 문서가 있습니다.
      C++
      C와 C++의 연산자
      C 언어
      C++0x
      C++11
      C++14
      C++17
      C++20
      표준 템플릿 라이브러리(STL)
      자바와 C++의 비교
      C++과 C#의 차이점
      C++/CLI
      C++/CX
      오브젝티브-C`,
    },
    {
      id: 22,
      title: "자바",
      contents: `자바(영어: Java)는 썬 마이크로시스템즈의 제임스 고슬링(James Gosling)과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린 프로젝트(Green Project)라는 이름으로 시작해 1995년에 발표했다. 처음에는 가전제품 내에 탑재해 동작하는 프로그램을 위해 개발되었지만 현재 웹 애플리케이션 분야에 가장 많이 사용하는 언어 중 하나이고, 안드로이드를 비롯한 모바일 기기용 소프트웨어 개발에도 널리 사용되고 있다. 현재 버전 18까지 출시했다.

      자바의 개발자들은 유닉스 기반의 배경을 가지고 있었기 때문에 문법적인 특성은 파스칼이 아닌 C++의 조상인 C 언어와 비슷하다.[3] 자바를 다른 컴파일언어와 구분 짓는 가장 큰 특징은 컴파일된 코드가 플랫폼 독립적이라는 점이다. 자바 컴파일러는 자바 언어로 작성된 프로그램을 바이트코드라는 특수한 바이너리 형태로 변환한다. 바이트코드를 실행하기 위해서는 JVM(자바 가상 머신, Java Virtual Machine)이라는 특수한 가상 머신이 필요한데, 이 가상 머신은 자바 바이트코드를 어느 플랫폼에서나 동일한 형태로 실행시킨다. 때문에 자바로 개발된 프로그램은 CPU나 운영 체제의 종류에 관계없이 JVM을 설치할 수 있는 시스템에서는 어디서나 실행할 수 있으며, 이 점이 웹 애플리케이션의 특성과 맞아떨어져 폭발적인 인기를 끌게 되었다.
      
      역사
      자바 언어는 1991년 6월 셋톱 프로젝트를 위해 제임스 고슬링(James Gosling)이 만들었다. 이 언어는 원래 제임스 고슬링의 사무실 밖에 있던 오크 나무를 따다 오크(Oak), 혹은 그린(Green) 이라고도 불렀으나, 단어 리스트 중 무작위로 뽑은 자바(Java)를 선택했다. 고슬링의 목표는 C/C++ 스타일의 언어와 가상 머신을 구현하는 것이었다. 첫 공개 자바 버전은 1995년의 자바 1.0이었다. 한 번 쓰고 어느 곳에도 실행 "Write Once, Run Anywhere"하는 것을 약속하였고 인기 플랫폼에 무료 런타임을 제공하였다. 이 플랫폼은 꽤 안정성을 지녔고 보안 시스템은 여러 설정을 통해 네트워크 및 파일 접근을 통제할 수 있었다. 대부분의 브라우저들은 곧 자바 애플릿(Java Applet)을 웹 페이지 안에서 실행할 수 있었고 자바의 인기는 급상승했다. 자바 2(JDK 1.2 ~ 1.4)의 출현으로 여러 다양한 플랫폼에서 사용할 수 있는 설정(Configuration)들을 만들었다. 예를 들어 J2EE는 엔터프라이즈 애플리케이션을 실행할 수 있고, J2ME는 모바일 애플리케이션을 실행할 수 있다. J2SE는 스탠다드 에디션으로 지정되었다. 2006년에 마케팅용으로 Java EE, Java ME, Java SE 순서대로 명칭을 바꾸었다.
      
      썬 마이크로시스템즈는 1997년 ISO/IEC JTC1 표준화 그룹, 그리고 나중에는 ECMA International 그룹과 접촉하여 정식 승인을 받으려 했으나 곧 이 프로세스에서 철수했다. 자바는 사실상 (de facto)의 표준이며 자바 커뮤니티 프로세스(Java Community Process)를 통해 관리되고 있다. 썬 마이크로시스템즈는 자바의 대부분을 무료로 배포하였으나 오픈이 아닌 사유 소프트웨어였다. 썬 마이크로시스템즈는 자바 엔터프라이즈 시스템 같은 특정 라이선스를 팔아서 수입을 올렸다. 썬(SUN) 사는 자사의 개발용(소프트웨어 개발 키트 (SDK))과 개발용의 일부인 실행용(자바 런타임 환경, JRE)을 구분한다. 실행용에는 컴파일러, 유틸리티 및 여러 개발용 헤더 파일이 포함되어 있지 않다.
      
      2006년 11월 13일 썬 마이크로시스템즈는 대부분은 자바를 GPL 라이선스로 소스를 오픈하였으며 2007년 5월 8일 이 과정을 마쳤다. 썬 마이크로시스템즈가 권한을 가지고 있지 않은 대부분의 코어 부분을 오픈하였다. 2009년 4월 20일 제작사인 썬 마이크로시스템즈가 오라클과 인수 합병됨에 따라 자바에 대한 권리 및 유지보수 또한 오라클로 넘어가게 되었다.
      
      
      Duke 자바 마스코트
      철학
      자바 언어는 다음 5가지의 핵심 목표를 지니고 있다.[4]
      
      객체 지향 방법론을 사용해야 한다.
      같은 프로그램(바이트코드)이 여러 운영 체제(마이크로프로세서)에서 실행될 수 있어야 한다.
      컴퓨터 네트워크 접근 기능이 기본으로 탑재되어 있어야 한다.
      원격 코드를 안전하게 실행할 수 있어야 한다.
      다른 객체 지향 언어들의 좋은 부분만 가지고 와서 사용하기 편해야 한다.
      자바는 초기 설계부터 객체 지향 언어(객체 지향 프로그래밍)로 설계되었다. C가 C++로 진화한 것과는 차이가 있다. 그리고 같은 코드로 어떤 마이크로프로세서에서나 실행되기를 원했다. 따라서 자바만의 실행 코드인 바이트코드라는 중간 코드를 컴파일러에 의해 생성한다. 그리고 자바 가상 머신(JVM)에 의해 해석되어 실행된다. 따라서 C/C++ 코드로 작성되어 생성된 코드보다 일대일 상황이면 실행 속도가 느리다. 그러나 장점은 같은 코드로 다양한 플랫폼이나 운영 체제에서 실행될 수 있다는 점이다.
      
      자바 실행 코드 생성 및 마이크로프로세서와 관계
      
      JVM 구조. 소스코드는 바이트코드로 컴파일되어 생성, 코드 검증, JVM에 의해 해석되어 실행(interpreted) 또는 JIT-compiled로 직접 기계어 코드로 변환 실행. JRE(Java Runtime Environment)에 API와 JVM이 함께 만들어짐.
      자바가 여러 개의 마이크로프로세서(CPU)에서 같은 코드가 실행되기 위해서는 C/C++의 프로그램의 실행 구조와는 다른 방식이 필요하다. C/C++가 특정 CPU의 기계어 코드를 직접 생성하면, 이 기계어 코드가 메모리에 적재되어 바로 실행된다. 따라서 C/C++는 CPU가 달라지면 컴파일러가 달라져야 한다. 임베디드 프로그램의 경우, gcc는 gcc 소스를 사용해서 특정 CPU를 지정하고, 컴파일러(x86 플랫폼에서)로 크로스 컴파일러를 만들 수 있다. x86 리눅스용 프로그램 만든다면, x86 컴파일러를 만들 수 있다. ARM용 프로그램이라면 ARM을 지정하고 컴파일러 소스를 컴파일러(x86에서 실행되는)로 ARM용 크로스 컴파일러를 만들 수 있다. 만약 gcc를 사용하고 싶지 않거나 gcc 컴파일러가 없다면, 특정 CPU 개발 도구는 구입을 해서 사용한다. 그러나 자바는 같은 코드를 사용하여 다른 CPU에서 실행되도록 하기 위해 직접 CPU의 기계어 코드를 생성해서는 안 된다. 그 대신 자바는 바이트코드(Java bytecode)라는 것을 생성한다. 이것을 자바 가상 머신(JVM, Java virtual machine)이 해석을 하여 실행한다. 자바 가상 머신이 인터프리터가 되어 코드 해석 방식의 실행을 함으로써, 같은 바이트코드를 가지고 여러 가지의 CPU에서 실행이 가능해진다. JVM은 CPU와 직접적 관계가 있으므로 이것은 CPU의 기계어 코드로 이루어진다.
      
      자바 실행 모델과 자바 바이트코드의 예
      자바의 실행 방식은 스택 실행 방식 언어(stack-oriented programming language)를 생각할 수 있다.
      
      int main()
      {
        int a = 10;
        int b = 20;
        int c;
         c = a + b;
         printf("%d", c);
         // 991
      }
      이것을 C/C++를 x86 프로세서용 컴파일러로 컴파일하면, 컴파일러와 최적화 등에 따라 다를 수 있지만 다음과 같은 예의 코드가 생성될 수 있다. C 언어에서 실행할 때, 지역변수는 스택이나 CPU의 레지스터를 이용한다. 스택이냐 레지스터냐는 개발 도구의 옵션에서 설정하는 최적화와 함수 내의 변수의 숫자와 관련이 있다. 함수의 블록이 시작되면 레지스터를 스택에 대피시키고, EBP를 스택의 포인터 값으로 설정하여 변수의 베이스 주소로 사용한다. 스택을 이용한다면 다음과 같은 어셈블리 결과를 생각할 수 있다.
      
      x86 프로세서에서 어셈블리어 코드 예는:
      
       mov eax, DWORD PTR 4[ebp]
       mov edx, DWORD PTR 8[ebp]
       add eax, edx
       mov DWORD PTR 12[ebp], eax
      이 코드는 2개의 정수형 숫자를 더해 다른 곳에 넣는 과정이다. 메모리에 적체된 코드를 x86이 읽어 실행시킬 수 있는 기계어로 일대일 대응된다. bp 레지스터는 CPU의 스택을 베이스로 한 포인터 레지스터이다. 주로 지역변수로 선언된 경우 스택을 사용한다.
      
      그러나 자바에서 보면:
      
      0 iload_1
      1 iload_2
      2 iadd
      3 istore_3
      2개의 숫자를 더하기 위해 스택에 넣고, 다시 스택에서 꺼내서 더한다. 더한 값을 다시 스택에 넣는다.
      
      이 코드는 특정 CPU의 기계어 코드가 아니라, 자바 고유의 기계어로 생각할 수 있는 코드 형태이다. JVM이 읽어 해석한 후, 해당 코드의 기능을 수행한다.
      
      버전
      자바의 버전은 보통 Java SE 또는 JDK/JRE의 버전으로 말한다.
      
      JDK(Java Development Kit)는 표준 라이브러리를 포함하며, JDK 버전이 바뀜에 따라 이 라이브러리가 확대되고 API가 바뀐다. 초기 1.0/1.1 버전에서 JDK/JRE의 명칭을 사용하다가 Java 1.2가 발표되면서 J2SDK/J2RE라고 개명하여 사용했으나 기존의 명칭으로 사용하는 사람들이 많아 현재는 다시 JDK/JRE의 명칭으로 돌아왔다. 또한 J2SE(Java2 Standard Edition)라는 명칭 또한 Java SE(Java Standard Edition)로 변경되었다.[5]
      
      자바 버전 체계의 메이저 버전(소수점 위)이 계속 1.x로 고정되어 마이너 업데이트로 여기는 경우들이 있어 1.5 버전부터 5.0(1.5), 6(1.6)의 형태로 제품 버전을 코드 버전과 별개로 발표하고 있다.[6]
      
      언어 자체는 자바 언어 명세(Java Language Specification, JLS)에서 정의되며, 판(edition)으로 구분한다. JDK가 확장되는 동안 언어는 2판에서 거의 변화가 없었으나, JDK 5와 함께 바뀐 JLS 3판에서 제네릭(generic) 타입, 애너테이션(annotation) 같은 기능이 도입되면서 상당히 바뀌었다.
      
      JDK 7에서는 자바 언어에 상당한 변화가 계획되어 있었으나 JDK 7로 예정되었던 변화가 JDK 7과 JDK 8로 나뉘면서 JDK 7에는 상대적으로 사소한 언어 특성만이 추가되었다. 구체적으로 이진수 표기 추가, 가독성을 위해 수 표기에 밑줄(underscore)을 허용, 스위치 문(switch에서 문자열 사용, 제네릭 타입 객체 생성 시 타입 추론(type inference), 자동 자원 해제를 위한 try 문법, 여러 예외 타입을 동시에 잡도록 허용하는 문법 등이 추가되었다. JDK 9는 사업적으로 엄청난 변화가 있었다. 언어적인 변화보단 사용방법이 바뀌었다. 먼저 사업적으로 사용이 안된다. 이게 무슨뜻이냐면 Java 8 까진 사업적으로 가능한데 JDK 9부터 안된다는 뜻이다. 한마디로 돈을 받고 Java 프로그램을 팔수 없게된다. 하지만 사업이 아닌 개인용 & 학생용은 16까지 가능하다
      
      버전	날짜
      JDK 베타	1995
      JDK 1.0	1996년 1월 23일[7]
      JDK 1.1	1997년 2월 19일
      J2SE 1.2	1998년 12월 8일
      J2SE 1.3	2000년 5월 8일
      J2SE 1.4	2002년 2월 6일
      J2SE 5.0	2004년 9월 30일
      Java SE 6	2006년 12월 11일
      Java SE 7	2011년 7월 28일
      Java SE 8 (LTS)	2014년 3월 18일
      Java SE 9	2017년 9월 21일
      Java SE 10	2018년 3월 20일
      Java SE 11 (LTS)	2018년 9월 25일[8]
      Java SE 12	2019년 3월 19일
      Java SE 13	2019년 9월 17일
      Java SE 14	2020년 3월 17일
      Java SE 15	2020년 9월 15일[9]
      Java SE 16	2021년 3월 16일
      Java SE 17 (LTS)	2021년 9월 14일
      Java SE 18	2022년 3월 22일
      예제
      Hello world
      다음은 자바를 사용해 작성한 전통적인 Hello world 프로그램이다.
      
      public class HelloWorldApp { //클래스. 메소드를 넣을 수 있다.
        public static void main(String[] args) { //메인 메소드의 시작지점이며 public 없이는 작동하지 않는다.
          System.out.println("Hello World!"); // Hello World를 출력한다. 하지만 Console이라는 구문이 따로있다.
        } // 메소드의 끝. 다른 메소드가 붙을 수 있다.
      } // 클래스의 끝. 다른 클래스가 붙을 수 있으나 해당 클래스는 public 이   붙어있지 않아야한다
      소스 파일명은 반드시 파일 내의 public class 이름과 동일해야 하며, 파일 확장자는 .java이어야 한다. 예를 들면, 만약 public class 이름이 HelloWorldApp이라면, 파일명은 반드시 HelloWorldApp.java가 되어야 한다. 이 자바 파일이 동작하기 위해서는 자바 컴파일러를 통해서 바이트코드로 컴파일되어 같은 이름의 .class 파일, 즉, HelloWorldApp.class가 생성되어야 한다. 컴파일된 class 파일은 자바 가상 머신을 통해 실행이 가능하다.
      리눅스/유닉스 터미널 (혹은 윈도우 cmd)에서 자바 파일을 컴파일한 후 실행하는 방법 예제)
      컴파일: 자바 컴파일러 사용 (예, javac)
      javac HelloWorldApp.java
      컴파일 후에는 같은 이름의 class 파일인 HelloWorldApp.class가 생성된다.
      
      실행: 자바 가상 머신 사용 (예, java)
      java HelloWorldApp
      실행 시에는 확장자인 .class를 붙이지 않는다.
      
      결과
      Hello World!
      자바 API
      <nowiki /> 자바 API 문서를 참고하십시오.
      자바 라이브러리
      자바 라이브러리(Java Library)는 Java 언어에 대한 라이브러리이다. org, net, javax, java와 같은 도메인 Import를 추가시켜 준다.
      
      자바 파생응용 분야
      자바 서버 페이지(JSP, JavaServer Pages)
      안드로이드 (운영 체제)
      한편 안드로이드는 자바 VM에 해당하는 달빅계열하에 오픈 자바 클래스를 기반으로한 API로 프로그래밍을 함으로 이 경우 특수한 경우의 자바 프로그래밍이라고 부를수있다.
      
      같이 보기
      자바 (소프트웨어 플랫폼)
      자바 가상 머신
      자바와 C++의 비교
      GNU 클래스패스
          `,
    },
    {
      id: 23,
      title: "프로그래밍 언어",
      contents: `프로그래밍 언어(programming language)는 컴퓨터 시스템을 구동시키는 소프트웨어를 작성하기 위한 형식언어이다. 고급 언어일수록 사람이 사용하는 언어에 가깝다.

      일반적으로 말할 때에는 프로그래밍 언어를 지원하는 소프트웨어, 곧 소프트웨어를 작성하기 위한 소프트웨어를 가리키는 때가 많고, 이때에는 프로그래밍 언어와 소프트웨어를 구분하지 않고 소프트웨어를 프로그래밍 언어로 보기도 한다.[출처 필요] 예를 들면, 델파이는 프로그래밍 언어인 오브젝트 파스칼을 지원하는 소프트웨어를 작성하기 위한 소프트웨어일 뿐이지만, 델파이를 별개의 프로그래밍 언어로 보는 때가 더 많다.[출처 필요]
      
      역사
      <nowiki /> 이 부분의 본문은 프로그래밍 언어의 역사입니다.
      최초의 컴퓨터는 종종 프로그래밍 언어의 도움 없이 프로그래밍되었는데, 이는 프로그램들을 절대적인 기계어로 작성함으로써 이루어졌다. 10진이나 이진 형태의 프로그램들은 천공 카드나 자기 테이프로부터 읽거나 컴퓨터 프론트 패널의 스위치를 켜고 끔으로써 불러들였다. 절대적인 기계어는 나중에 1세대 프로그래밍 언어(1GL)로 명칭이 정해졌다.
      
      다음 단계로 이른바 2세대 프로그래밍 언어(2GL), 곧 어셈블리어가 개발되었으며 여전히 특정 컴퓨터의 명령어 집합 구조와 밀접하게 관계되었다. 프로그램을 훨씬 더 인간이 읽기 쉽게 만들어주었을 뿐 아니라, 주소 계산 시 따분하고 오류가 발생할 경향이 있는 프로그래머를 안심시켜 주었다.
      
      최초의 고급 프로그래밍 언어, 즉 3세대 프로그래밍 언어(3GL)는 1950년대에 작성되었다. 컴퓨터용으로 설계될 초기의 고급 프로그래밍 언어는 Plankalkül였으며, 콘라트 추제가 1943년부터 1945년까지 독일의 Z3용으로 개발될 것이었다. 그러나 1998년, 2000년까지 구현되지 않았다.[1]
      
      4세대 프로그래밍 언어(4GL)는 3세대 프로그래밍 언어 보다 내부 컴퓨터 하드웨어의 상세한 부분을 더 고급적으로 추상화시키는 것을 목적으로 한다. 5세대 프로그래밍 언어(5GL)는 프로그래머가 작성한 알고리즘을 이용하지 않고, 프로그램에 주어지는 제약을 사용하여 문제를 해결하는 언어이다.
      
      A언어부터 C언어까지
      C언어의 C는 약간의 의미를 가지고 있다. 이는 프로그래밍 언어의 역사와도 관련이 되어 있다. 통상 A언어부터 B언어, C언어 순으로 발전해 왔다고 일컬어진다.
      
      A언어 : 과거에는 ALGOL을 의미했다. (ALGOL은 Algorithm Language의 약자로, 알고리즘 연구개발을 위해 만들어졌다.) 현재는 특정 프로그래밍 언어를 지칭한다기 보다, 구조화된 프로그래밍 언어를 지칭하는 용어로 이용한다.
      B언어 : 켄 톰슨(Ken Thompson)이 DEC사의 PDP-7으로 어셈블리어로 유닉스라는 운영 체제를 만들게 되었는데, 이후 이 운영 체제를 고급언어로 다시 만들기 위해 마틴 리차드(Matin Richards)의 BCPL(Basic CPL, CPL = Combined Programming Language)을 바탕으로 B라는 언어를 만들게 되었다. 이 언어는 자료형이 없었는데, 이는 C언어를 만드는 계기가 되었다.
      C언어 : 켄 톰슨이 만든 B언어를 보고, 그의 동료였던 데니스 리치가 1972년에 B언어에 데이터 유형 개념을 추가하여 만든 언어이다. 이후 유닉스의 구현언어로 B언어를 제치고 C언어가 채택되면서 이듬해인 1973년에 C언어로 구현된 유닉스가 만들어지게 되었다.
      구조
      이 문단의 내용은 출처가 분명하지 않습니다.
      이 문단을 편집하여, 신뢰할 수 있는 출처를 표기해 주세요. 검증되지 않은 내용은 삭제될 수도 있습니다. 내용에 대한 의견은 토론 문서에서 나누어 주세요. (2009년 6월)
      컴퓨터 프로그램은 데이터(data)와 명령어(instruction), 이렇게 두 부분으로 나뉜다. 데이터는 일련의 바이트 형식으로 저장된다. 프로그래밍 언어는 이런 바이트들을 유용한 형태로 정리한다. 사용자는 필요에 따라 데이터를 다음과 같이 선언(declaration)할 수 있다.
      
       int MyData; // 정수형 데이터
      이와 같이 선언하면, 컴퓨터 메모리의 한 영역을 'MyData'라는 이름의 정수(integer) 타입으로 저장한다. 메모리의 어느 영역에 데이터를 저장할 것인가는 컴파일러가 결정한다. 일반적으로 사용자는 컴파일러의 내부가 어떻게 동작하는지 몰라도 프로그램을 만들 수 있다. 'MyData'는 간단한 변수(variable)이고, 한 개의 정수만 변수에 담을 수 있다. 여러 개의 변수를 만들고 싶으면 아주 간단하게 배열(array)을 만들 수 있다.
      
       int MyArray[100]; // 100개의 정수형 변수 선언
      소프트웨어 공학의 발달로 보다 복잡한 자료형들이 필요해졌다. 예를 들어, 사각형을 만드는 데 필요한 자료형을 정의한다고 하자. 한 사각형을 정의하려면 너비, 높이, 색과 같은 여러 정보가 동시에 필요하다. 따라서, 위와 같은 변수나 배열의 선언만으로는 이런 정보들을 잘 정의하기가 어렵다. C 언어와 같은 고급 언어(high-level language)는 보다 정교한 자료형의 선언을 지원하여 여러 가지 다른 형식의 데이터 선언들을 한데 엮은 새로운 자료형을 만들 수 있다.
      
      struct rectangle {
        int width;        // 사각형의 너비를 픽셀 단위로 저장
        int height;       // 사각형의 높이를 픽셀 단위로 저장
        color_type color; // 사각형의 색 정보를 저장
      };
      이러한 데이터들을 활용하기 위해서는 컴퓨터에게 지시를 내려야 한다. 컴퓨터는 현재 실행하고 있는 지시의 내용과 다음에 실행할 지시의 위치만 알고 있다. 컴퓨터 언어는 컴퓨터의 하드웨어를 직접 제어하는 초기의 어셈블리와 같은 언어에서부터 시작하여 현재에는 C 언어와 같은 고급 언어(high-level language)로 발전되어 왔다. 프로그램 언어가 상위 레벨로 발전될수록 프로그램은 좀 더 인간의 언어에 가까운 형태가 된다. 이에 따라 프로그램 언어의 학습과 프로그램의 구현이 보다 수월해진다.
      
      프로그래머는 상위 레벨의 지시문으로 프로그램을 작성하면 컴파일러가 이 지시문을 컴퓨터가 이해할 수 있는 기계어로 번역한다. 지시문들을 한데 묶어 놓은 것들을 함수(function)이라 한다. 함수는 특정한 동작을 일반적인 형태로 정의해 놓은 지시문의 집합이다. 똑같은 동작이 필요하면 지시문을 다시 작성할 필요없이 함수의 매개변수를 이용하여 계속 사용할 수 있다.
      
      예를 들어, C 언어는 검색, 정렬, 입출력에 관련된 다양하고 풍부한 표준 함수(standard functions)들을 제공한다. 이런 표준 함수가 제공되는 덕분에 사용자는 해당 함수를 만드는 데 드는 노력을 절약할 수 있다. 연결된 함수들을 한데 묶어 놓은 것은 모듈(module)이라 하고, 모듈들의 상호 연결로 하나의 프로그램이 구성된다. 그리고 이러한 모듈들을 재사용할 수 있게 모아둔 것을 라이브러리라 한다.
      
      비교
      <nowiki /> 이 부분의 본문은 프로그래밍 언어의 비교입니다.
      주요 프로그래밍 언어의 목록
      <nowiki /> 이 부분의 본문은 프로그래밍 언어 목록입니다.
      저급 언어
      기계어
      어셈블리어
      고급 언어
      베이직
      C
      C#
      C++
      D
      F#
      파이썬
      루비
      자바
      코틀린
      파스칼
      프롤로그
      포트란
      코볼
      리스프
      펄
      R
      그루비
      스칼라
      occam
      Swift
      예
      한편 객체 지향 프로그래밍언어(OOP)인 자바스크립트에서 사용되는 기초적인 문법의 개념으로는 속성과 메쏘드를 갖는 객체(오브젝트) 개념이 있으며, 변수 선언, 함수 정의, 연산자 그리고 제어문 등을 주요하게 들수 있다.
      
      같이 보기
        위키미디어 공용에 관련된
      미디어 분류가 있습니다.
      프로그래밍 언어
      난해한 프로그래밍 언어`,
    },
    {
      id: 24,
      title: "운영체제",
      contents: `운영체제(運營 體制, 문화어: 조작 체계) 또는 오퍼레이팅 시스템(operating system, 약칭: OS)은 사용자의 하드웨어, 시스템 리소스를 제어하고 프로그램에 대한 일반적 서비스를 지원하는 시스템 소프트웨어이다. 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공한다. 최근에는 가상화 기술의 발전에 힘입어 실제 하드웨어가 아닌 하이퍼바이저(가상 머신) 위에서 실행되기도 한다.

      또한 입출력과 메모리 할당과 같은 하드웨어 기능의 경우 운영체제는 응용 프로그램과 컴퓨터 하드웨어 사이의 중재 역할을 한다.[1][2] 그러나 응용 프로그램 코드는 일반적으로 하드웨어에서 직접 실행된다. 운영체제는 휴대 전화, 게임기에서부터 슈퍼컴퓨터, 웹 서버에 이르기까지 컴퓨터를 포함하는 거의 모든 장치에서 볼 수 있다. 운영체제는 한 면으로는 소비자를, 다른 한 면으로는 프로그램 개발자를 함께 하나의 시장으로 데려다 놓을 수 있는 양면 플랫폼이다. 잘 알려진 현대의 PC 운영체제에는 마이크로소프트 윈도우, 맥 OS X, 리눅스가 있다.[3] 이 밖에 BSD, 유닉스 등의 PC용 운영체제도 존재한다.
      
      운영체제는 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치 등의 자원들을 사용할 수 있도록 만들어 준다. 더불어, 이들을 추상화하여 파일 시스템 등의 서비스를 제공한다. 또한 멀티태스킹을 지원하는 경우, 여러 개의 응용 프로그램을 실행하고 있는 동안, 운영체제는 이러한 모든 프로세스들을 스케줄링하여 마치 그들이 동시에 수행되는 것처럼 보이는 효과를 낸다.
      
      또한 운영체제는 컴퓨터 과학의 연구 분야이기도 하다.
      
      종류
      싱글태스킹 운영체제 / 멀티태스킹 운영체제
      싱글 태스킹 운영체제는 한번에 오직 하나의 프로그램만 실행할 수 있으나 멀티태스킹 운영체제는 하나 이상의 프로그램이 동시에 실행할 수 있게 한다. 이는 운영체제의 작업 스케줄링 하부 시스템에 의해 제각기 반복적으로 인터럽트 처리되는 여러 프로세스 사이에서 이용 가능한 프로세서 시간을 쪼개는 시분할을 통해 이루어진다. 멀티태스킹의 경우 선점형과 협동형(비선점형)이 있다. 선점형 멀티태스킹의 경우 운영체제는 CPU 시간을 쪼개어 프로그램들 각각에 슬롯을 할당해준다. 솔라리스, 리눅스, 아미가OS와 같은 유닉스 계열 운영체제들은 선점형 멀티태스킹을 지원한다. 협동형 멀티태스킹은 정해진 방식에 따라 다른 프로세스들에 시간을 제공하기 위해 각 프로세스에 의존함으로써 수행된다. 16비트 버전의 마이크로소프트 윈도우는 협동형 멀티태스킹을 사용하였다. 32비트 버전의 윈도우 NT, 윈도우 9x의 경우 선점형 멀티태스킹을 사용하였다.
      
      단일 사용자 운영체제 / 다중 사용자 운영체제
      단일 사용자 운영체제는 사용자 구별이 없으나 여러 프로그램이 나란히 실행하는 것은 허용한다.[4] 다중 사용자 운영체제는 디스크 공간과 같은 리소스와 프로세스를 식별하는 기능을 갖춘 멀티태스킹의 기본 개념을 확장하며, 여러 사용자에 속해 있으면서 여러 사용자가 동시에 시스템과 상호 작용할 수 있게 한다. 시분할 운영체제들은 시스템의 효율적인 이용을 위해 태스크를 스케줄링하며, 프로세서 시간, 기억 공간, 인쇄, 기타 자원을 여러 사용자에게 비용적으로 할당하기 위한 회계 소프트웨어를 포함할 수 있다.
      
      분산 운영체제
      분산 운영체제는 구별된 컴퓨터 그룹을 관리하고 이들이 마치 하나의 컴퓨터인 것처럼 보이게 만들어 준다. 서로 연결되어 통신하는 네트워크화된 컴퓨터들이 개발되면서 분산 컴퓨팅이 활성화되었다. 분산되는 연산들은 하나 이상의 컴퓨터에서 수행된다. 하나의 그룹에 속하는 컴퓨터들이 협업을 할 때 분산 시스템을 형성하게 된다.[5]
      
      판형 운영체제
      운영체제에서, 배포 형식 및 클라우드 컴퓨팅 환경에서 판형은 하나의 가상 머신 이미지를 게스트 운영체제로 만드는 것을 가리키며, 실행 중인 여러 개의 가상 머신을 위한 도구로 이를 저장한다. 이 기법은 가상화와 클라우드 컴퓨팅 관리에 둘 다 사용되며, 대형 서버 웨어하우스 환경에서 흔히 볼 수 있다.[6]
      
      임베디드 운영체제
      임베디드 운영체제는 임베디드 컴퓨터 시스템에서 사용할 수 있게 설계되어 있다. PDA처럼 조그마한 기계에 동작하도록 설계되어 있으며 ,제한된 수의 자원으로 동작한다. 매우 크기가 작고 극히 효율적으로 설계되어 있다. 임베디드 운영체제의 예로 윈도우 CE와 미닉스 3이 있다.
      
      실시간 운영체제
      실시간 운영체제는 특정한 짧은 시간 내에 이벤트나 데이터의 처리를 보증하는 운영체제이다. 실시간 운영체제는 싱글태스킹일 수도 있고, 멀티태스킹일 수도 있으며 멀티태스킹의 경우 특수한 스케줄링 알고리즘을 사용한다.
      
      라이브러리
      라이브러리 운영체제는 네트워크 등 일반적인 운영체제가 제공하는 서비스들이 라이브러리 형태로 제공되는 것을 의미한다.
      
      운영체제의 구성
      운영체제는 많은 부분을 이룬다. 가장 중요한 요소 가운데 하나가 커널인데, 커널은 일반인이 일반적으로 보지 못하는 낮은 수준의 프로세스를 제어한다. 얼마나 메모리를 읽고 쓸 것인지, 어느 프로세스를 실행할 것인지, 모니터, 키보드, 마우스와 같은 장치를 통해 어떠한 정보를 주고받을 것인지, 네트워크를 통해 받은 정보를 어떻게 해석할 것인지를 제어한다.
      
      사용자 인터페이스는 컴퓨터 사용자가 직접 프로그램을 제어하고 사용할 수 있게 하는 운영체제의 기능이다. 사용자 인터페이스는 아이콘과 바탕 화면을 지닌 그래픽이나 명령 줄을 지닌 문자를 이룰 수 있다.
      
      이와 비슷한 기능으로 API가 있는데 이것은 응용 프로그램이 다른 프로그램과 상호 작용할 수 있게 하는 서비스와 코드 라이브러리가 한데 모여 있으며 운영체제 그 자체라고 할 수도 있다.
      
      운영체제에 따라 이러한 구성 요소들 가운데 다수가 실질적인 부분으로 취급되지 않을 수도 있다. 이를테면 윈도우는 사용자 인터페이스를 운영체제의 일부로 여기는데 반해 수많은 버전의 리눅스는 그렇지 않다.
      
      목적
      운영체제의 중요한 목적은 이를테면 다음과 같다.
      
      사용자에게 컴퓨터의 프로그램을 쉽고 효율적으로 실행할 수 있는 환경을 제공한다.
      컴퓨터 시스템 하드웨어 및 소프트웨어 자원을 여러 사용자 간에 효율적 할당, 관리, 보호하는 것
      운영체제는 제어 프로그램으로서 사용자 프로그램의 오류나 잘못된 자원 사용을 감시하는 것과 입출력 장치 등의 자원에 대한 연산과 제어를 관리한다.
      시스템 구성
      일반적인 응용 프로그램들을 제외한 컴퓨터 시스템은 개념적으로 세 개의 구성 요소로 구분하기도 한다. 그 세 부분은 운영체제, 셸, 그리고 (낮은 수준의) 필수 유틸리티들이다. 셸은 사용자가 시스템을 운용할 수 있게끔 해주는 기본적인 응용 프로그램이다. 이런 셸의 행동들은 결국 운영체제에 명령을 내리는 일이 된다. bash 등의 이러한 셸은 그러나 엄밀히 운영체제의 일부가 아니며 운영체제 입장에서는 셸이나 필수 유틸리티들이나 모두 응용 프로그램일뿐 구별하지 않는다. 다만 이러한 구분은 사용자의 입장에서 필수적인 응용 프로그램이라는 뜻이다.
      
      하드웨어 ↔ 운영체제 ↔ 셸 / 응용 프로그램 ↔ 사용자
      
      역사
      <nowiki /> 이 부분의 본문은 운영체제의 역사입니다.
      
      나사가 달에 사람을 착륙시키는 데 도움을 준 컴퓨터를 포함하여 OS/360은 1966년부터 대부분의 IBM 메인프레임 컴퓨터에 쓰였다.
      초기의 컴퓨터들은 계산기처럼 일련의 단일 작업들을 수행하기 위하여 만들어졌다. 여러 프로그램들을 연속으로 자동 실행하여 처리 속도를 높일 수 있었던 레지던트 모니터와 같이, 1950년대에는 기본적인 운영체제의 기능들이 개발되었다. 운영체제는 1960년대 초까지만 하여도 현대의 운영체제와 같이 더 복잡한 형태로 존재하지 않았다.[7] 하드웨어 기능에 런타임 라이브러리, 인터럽트, 병렬 처리가 추가되었다. 개인용 컴퓨터가 애플, 아타리, IBM, 아미가와 같은 기업 덕택에 1980년대에 유명해졌다. 이 업체들은 한때 메인프레임과 미니 컴퓨터에 널리 쓰였던 운영체제 기능을 추가하였다. 나중에 그래픽 사용자 인터페이스와 같은 수많은 기능들이 개인용 컴퓨터 운영체제를 위해 개별적으로 개발되었다.
      
      1950년대 초에 컴퓨터는 한 번에 하나의 프로그램만 실행할 수 있었다. 각 사용자는 컴퓨터만을 사용하여 예약된 시간에 천공 카드와 테이프의 프로그램과 데이터에 접근하여야 했다. 프로그램이 컴퓨터에 적재되면 컴퓨터는 프로그램이 끝나거나 충돌을 일으킬 때까지 계속 동작하였다. 토글 스위치와 패널 불빛을 이용하여 앞면 패널을 통해 프로그램을 디버깅할 수 있었다.
      
      그 뒤에 나온 컴퓨터는 인간이 알아들을 수 있는 어셈블리어로부터의 기계어 발생이나 입출력과 같은 기능을 도와주기 위하여 사용자 프로그램을 연결해 놓은 소프트웨어 라이브러리와 함께 등장하였다. 이것이 현대의 운영체제의 시발점이다. 그러나 여전히 컴퓨터는 한 번에 하나의 일만 할 수 있었다.
      
      메인프레임
      <nowiki /> 이 부분의 본문은 메인프레임입니다.
      1950년대를 통해 일괄 처리, 입출력 인터럽트, 버퍼링, 멀티태스킹, 스풀링, 런타임 라이브러리, 파일 정렬을 위한 프로그램을 포함한 수많은 주요 기능들이 운영체제 분야에 포함되었다. 이러한 기능들은 프로그래머의 취향에 따라 응용 소프트웨어에 포함되어 있기도 했고 포함되지 않기도 했다. 1959년에 IBM 704, 709, 7090 메인프레임 컴퓨터를 위한 셰어 운영체제(SHARE)가 통합 유틸리티로 출시되었다.
      
      마이크로컴퓨터
      
      PC-DOS는 명령 줄 인터페이스 기능을 제공하였던 초기의 개인용 컴퓨터 운영체제였다.
      최초의 마이크로컴퓨터는 메인프레임과 미니컴퓨터를 위해 개발해 둔 운영체제에 대한 필요성도 그만한 용량도 없었다. 모니터스(Monitors)라는 이름의 매우 작은 운영체제가 개발되었으며 롬에서 불러들였다. 눈에 띄는 초기의 디스크 기반 운영체제로 CP/M이 있었는데 수많은 초기 마이크로컴퓨터에서 지원되었으며 IBM PC에 널리 쓰였던 MS-DOS(IBM 버전의 것은 IBM DOS, 곧 PC-DOS로 불렸다)와 매우 비슷하였다. 1980년대에 애플 컴퓨터사(지금의 애플사)가 애플 II 시리즈의 마이크로컴퓨터를 버리고, 혁신적인 그래픽 사용자 인터페이스를 맥 OS 운영체제에 갖춘 애플 매킨토시 컴퓨터를 도입하였다.
      
      32비트 아키텍처에 페이징 기능을 갖춘 인텔 80386 CPU 칩이 도입되면서 개인용 컴퓨터가 초기의 미니컴퓨터와 메인프레임 컴퓨터에서 실행할 수 있었던 멀티태스킹 운영체제를 사용할 수 있게 되었다. 마이크로소프트는 DEC용 VMS 운영체제를 개발하였던 데이비드 커틀러를 해고함으로써 이러한 진행에 응하였다. 그는 마이크로소프트의 운영체제 기반을 다룰 윈도우 NT 운영체제 개발을 이끌었다. 애플의 공동 창립자 스티브 잡스는 NeXT 컴퓨터사를 차렸고 유닉스 계열 넥스트스텝 운영체제를 개발하였다. 넥스트스텝은 훗날 애플에 인수되었으며 FreeBSD 코드가 맥 OS X의 중심이 되었다.
      
      프로그래머 리처드 스톨만이 사유 유닉스 운영체제를 대체하는 자유 소프트웨어를 목표로 GNU 프로젝트를 시작하였다. 이 프로젝트가 유닉스 여러 곳의 기능을 복제하는 데 큰 성공을 이루자 GNU 허드 커널 개발은 비생산적인 것으로 입증되었다. 1991년 핀란드 컴퓨터 과학부 학생인 리누스 토르발스는 최초의 리눅스 커널 버전을 출시하였다. 곧 GNU 유저랜드와 시스템 소프트웨어에 병합되면서 컴퓨터 운영체제를 이루게 되었다. BSD는 유닉스 계열로서 1970년대에 시작하여 수많은 미니컴퓨터에 포팅되었으며 마침내 FreeBSD, NetBSD, OpenBSD와 같이 개인용 컴퓨터에도 쓰이게 되었다.
      
      운영체제의 예
      <nowiki /> 이 부분의 본문은 운영체제 목록입니다.
      유닉스 및 유닉스 계열 운영체제
      <nowiki /> 이 부분의 본문은 유닉스 및 유닉스 계열입니다.
      
      유닉스 계열의 역사
      유닉스는 처음에는 어셈블리어로 작성되었다.[8] 켄 톰프슨은 BCPL에 기반을 둔 B를 작성하였다. 이것으로 말미암아 그는 유닉스를 작성하기도 하였는데, 이는 멀틱스 프로젝트에서의 경험을 바탕으로 한다. C는 B를 대체하였으며 유닉스는 현대의 모든 운영체제에 영향을 미쳤던 크고 복잡한 계열의 상호 관련 운영체제로 발전하였다. (역사 참조) 유닉스 계열 운영체제는 유닉스에서 파생한 계열이며 시스템 V, BSD, GNU/리눅스,와 같은 주된 하부 분류가 몇 가지 있다. 유닉스라는 이름은 어느 운영체제와도 사용할 수 있게 한다는 것을 표명한 오픈 그룹의 상표이다. 유닉스 계열은 원래의 유닉스를 닮은 커다란 집합의 운영체제들을 가리키는 데 흔히 쓰인다.
      
      유닉스 계열 운영체제는 다양한 컴퓨터 아키텍처에서 돌아간다. 이들은 비즈니스 분야의 서버와 학술 및 공학 환경에서의 워크스테이션에서도 쓰인다. GNU/리눅스와 BSD와 같은 자유 유닉스들은 이러한 분야에서 널리 쓰인다.
      
      HP의 HP-UX와 IBM의 AIX는 제조업체의 하드웨어에만 동작하도록 설계되어 있다. 솔라리스와 같은 것들은 x86 서버와 PC를 포함한 여러 종류의 하드웨어에서 돌아간다. 넥스트스텝, 마하, FreeBSD에서 파생한 하이브리드 커널 기반의 BSD류인 애플의 맥 OS X은 유닉스 계열이 아니었던 애플의 초기 맥 OS를 대체하였다. 유닉스의 정보 처리 상호 운용성은 POSIX 표준을 확립함으로써 드러난다. POSIX 표준은 이것이 비록 다양한 유닉스 계열을 위해서 만들어지기는 하였으나 다른 어떠한 운영체제에라도 적용할 수 있다.
      
      BSD 및 BSD 계열
      <nowiki /> 이 부분의 본문은 BSD입니다.
      
      월드 와이드 웹을 위한 최초의 서버는 BSD 기반의 넥스트스텝에서 실행하였다.
      유닉스 계열의 하부 집합 가운데 하나로 BSD 계열이 있다. 여기에는 FreeBSD, NetBSD, OpenBSD를 포함한다. 이러한 운영체제들은 웹 서버에서 가장 쉽게 찾을 수 있지만 개인용 컴퓨터 운영체제로의 역할도 한다. 인터넷은 BSD와도 많은 관련이 있는데, 네트워크에 연결하여 데이터를 주고 받는 데 흔히 쓰이는 현재의 프로토콜들 가운데 다수가 BSD에서 정의하여 널리 쓰이게 된 것이다. 또, 월드 와이드 웹은 넥스트스텝이라는 BSD 기반 운영체제를 실행하는 수많은 컴퓨터에서 처음 입증되었다.
      
      BSD는 유닉스에 뿌리를 두고 있다. 1974년에 캘리포니아 대학교 버클리는 최초의 유닉스 시스템을 설치하였다. 시간이 지나 컴퓨터 과학부의 학생들과 직원들은 그곳에서 문서 편집기와 같은 새로운 프로그램을 이러한 것들에 일찍이 추가하기 시작하였다. 버클리 대학교가 최초의 유닉스 시스템이 설치된 새로운 VAX 컴퓨터를 1978년에 도입하였을 때 대학생들은 컴퓨터 하드웨어의 가능성을 이용하기 위하여 유닉스를 수정하였다. 미국 국방부의 방위고등연구계획국이 이에 관심을 가져 프로젝트에 투자하기로 결정하였다. 수많은 학교와 회사, 정부 단체들은 이를 알아채고 AT&T에서 제공하는 공식적인 것이 아닌 버클리 버전의 유닉스를 사용하기 시작하였다. 1985년에 애플을 떠났던 스티브 잡스는 넥스트스텝이라 불리는 BSD류를 실행하는 고성능 컴퓨터를 제조하였던 기업 NeXT사를 세웠다. 이러한 컴퓨터들 가운데 하나는 팀 버너스 리가 최초의 웹 서버로 월드 와이드 웹을 만드는 데 사용하였다.
      
      OS X
      <nowiki /> 이 부분의 본문은 macOS입니다.
      <nowiki /> 맥 OS 문서를 참고하십시오.
      맥 OS X은 매킨토시 컴퓨터에 미리 최신으로 설치되어 있으면서도 애플이 개발하여 판매한 사유 그래픽 운영체제이다. 맥 OS X은 1984년 이후로 애플의 사유 운영체제였던 원래의 맥 OS의 뒤를 잇는 것이다. 전작과 달리 맥 OS X은 1980년대 2/4 분기부터 애플이 1987년 초에 이 회사를 사들일 때까지 NeXT에서 개발한 기술로 만든 유닉스 운영체제이다.
      
      이 운영체제는 1999년에 맥 OS X 서버 1.0이라는 이름으로 처음 출시하였으며 그 뒤 2001년 3월에 데스크톱 지향 버전인 맥 OS X v10.0을 출시하였다. 그 뒤로 맥 OS X의 "클라이언트", "서버" 에디션 여섯 가지가 공개되었으며, 최신 제품은 2020년에 출시된 OS X 빅서이다.
      
      서버 에디션인 맥 OS X 서버는 구조적으로 데스크톱의 것과 비슷하지만 일반적으로 애플의 매킨토시 서버 하드웨어에서 돌아간다. 맥 OS X은 메일 전송 에이전트, 삼바, LDAP 서버, DNS 등을 비롯한 네트워크 서비스에 접근할 수 있게 하는 워크 그룹 관리 및 관리 소프트웨어 도구를 포함하고 있다.
      
      플랜 9
      <nowiki /> 이 부분의 본문은 플랜 9 (운영체제)입니다.
      켄 톰프슨, 데니스 리치, 더글라스 맥길로이는 벨 연구소에서 유닉스 운영체제를 개발하기 위하여 C 프로그래밍 언어를 설계하고 개발하였다. 벨 연구소의 프로그래머들은 현대의 배포 환경을 위해 계획된, 플랜 9와 인페르노를 개발하기 시작하였다. 플랜 9는 네트워킹 운영체제로 발돋움하기 위하여 계획된 것이었으며 당시 그래픽이 제공되지 않았던 유닉스와 달리 그래픽을 내장하였다. Lucent 공중 허가 사용 허가서 하에 출시되었다. 인페르노는 Vita Nuova Holdings에 팔려 GPL/MIT 라이선스로 배포되고 있다.
      
      리눅스와 GNU
      <nowiki /> 이 부분의 본문은 GNU, 리눅스 및 리눅스 커널입니다.
      
      리눅스의 데스크톱 배포판인 우분투.
      
      안드로이드는 리눅스 커널을 이용하는 대중적인 모바일 운영체제이다.
      리눅스는 BSD 및 그 변종과 달리 실제 유닉스 코드 없이 개발된 유닉스 계열 운영체제이다. 슈퍼컴퓨터에서부터 손목시계에 이르기까지 다양한 기기에 쓰인다. 리눅스 커널은 오픈 소스 라이선스로 배포되므로 누구나 코드를 읽고 수정할 수 있다. 리눅스는 다양한 전자 기기에서 동작하도록 수정되고 있다.
      
      GNU 프로젝트는 완전한 원래의 코드를 제외하고 유닉스와 비슷하게 완전하게 자유롭고 열려 있는 운영체제를 만들고 싶어하는 프로그래머들의 협동적인 노고 그 자체이다. 이 프로젝트는 1983년에 리처드 스톨만이 시작하였고 대부분의 리눅스의 수많은 부분을 책임지고 있다. 이 까닭에 리눅스는 GNU/리눅스로 불리기도 한다. 실질적으로 모든 운영체제를 위한 수많은 소프트웨어가 GNU 일반 공중 사용 허가서 하에 배포된다. 이 가운데 리눅스 커널은 핀란드의 대학교 학생이었던 리누스 토르발스의 부차적인 프로젝트로 시작되었다. 1991년에 토르발스는 이 작업에 착수하여 프로젝트에 대한 정보를 컴퓨터 학생과 프로그래머를 위한 뉴스그룹에 게시하였다.
      
      구글 크롬 OS
      <nowiki /> 이 부분의 본문은 구글 크롬 OS입니다.
      크롬은 구글이 리눅스 커널을 기반으로 설계한 운영체제이다. 크롬은 대부분의 시간을 인터넷으로 보내는 이용자들을 대상으로 한다. 기술적으로는 어떠한 응용 프로그램도 없는 웹 브라우저만을 이용하며 문서 작성이나 미디어 보기와 같은 작업을 위해 웹 브라우저에 쓰이는 인터넷 애플리케이션에 의존한다.
      
      마이크로소프트 윈도우
      <nowiki /> 이 부분의 본문은 마이크로소프트 윈도우입니다.
      마이크로소프트 윈도우는 개인용 컴퓨터에 가장 흔히 쓰이는 사유 운영체제 계열이다. 개인용 컴퓨터를 위한 가장 흔한 운영체제이며 약 90%의 시장 점유율을 차지하고 있다.[9][10][11] 최신 버전은 개인용 컴퓨터의 경우 윈도우 11이, 서버의 경우 윈도우 서버 2019이다.
      
      1981년에 IBM PC용의 오래된 MS-DOS 운영체제에 추가 기능으로 나온 것이 기원이다. 1985년에 마이크로소프트는 개인용 컴퓨터의 비즈니스 분야를 지배하기 시작하여 수많은 산업 표준을 정립하기에 이르렀다. 윈도우 XP를 시작으로 현대의 모든 윈도 버전은 윈도우 NT 커널을 기반으로 하고 있다. 현재 나오는 윈도우 버전은 IA-32와 x86-64 프로세서에서 동작하지만 그 이전에 나왔던 버전들은 다른 아키텍처를 지원하기도 하였다.
      
      기타
      틈새 시장에 존재하는 오래된 운영체제로는 IBM과 마이크로소프트의 OS/2, 애플 맥 OS X의 유닉스를 이용하지 않는 이전작 맥 OS, 또 BeOS와 XTS-300이 있다. RISC OS, MorphOS, 아미가OS 4도 열성적인 커뮤니티와 전문 분야를 위한 소수 플랫폼으로 개발이 이어지고 있다. DEC의 OpenVMS도 휴렛 패커드가 계속 개발하고 있다. 도스 등의 운영체제도 FreeDOS와 같은 프로젝트를 통해 명맥을 이어가고 있다. 그 밖의 운영체제는 운영체제 교육용이나 학술용, 또는 운영체제 개념의 연구 등을 위해 예외적으로 쓰인다. 학술과 연구 역할을 모두 수행하는 시스템의 전형적인 예로 미닉스가 있다. 반면 순수 연구 목적으로 쓰이는 것으로는 싱귤래러티가 있다.
      
      구성 요소
      운영체제를 이루는 요소는 컴퓨터의 다른 부분들과 함께 동작하게 만들기 위하여 존재한다. 금융 데이터베이스부터 영화 편집 프로그램에 이르기까지 소프트웨어는 모두 소프트웨어에 쓰이는 하드웨어가 단순히 마우스나 키보드만 이용하든지 아니면 인터넷 연결같이 복잡한 방식을 이용하든지 상관 없이 하드웨어를 이용하기 위하여 운영체제로 말미암아 실행해야 한다.
      
      커널
      <nowiki /> 이 부분의 본문은 커널 (컴퓨팅)입니다.
      
      커널이 응용 소프트웨어를 컴퓨터 하드웨어에 연결하고 있다.
      펌웨어와 장치 드라이버의 도움을 받아 커널은 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 제공한다. 커널은 램을 통해 프로그램을 위한 메모리 접근을 관리하며 어느 프로그램이 어느 하드웨어 자원에 접근할지를 결정하며 CPU의 동작 상태를 늘 최적으로 설정 및 초기화하고 디스크, 테이프, 플래시 메모리와 같은 매체의 파일 시스템을 갖춘 장시간 비휘발성 기억 장치를 위한 데이터를 정리한다. 운영체제 내에서의 커널의 영역과 그 구성에 따라 모노리딕 커널(monolithic kernel), 마이크로 커널(micro kernel) 등으로 분류한다.
      
      프로그램 실행
      <nowiki /> 이 부분의 본문은 프로세스입니다.
      운영체제는 응용 프로그램과 하드웨어 사이의 인터페이스 역할을 한다. 운영체제는 응용 프로그램 개발을 단순하게 하는 서비스의 집합이다. 프로그램을 실행하면 운영체제가 프로세스를 만든다. 커널은 메모리와 다른 자원을 할당하여 프로세스를 만들며, 이로써 멀티태스킹 환경에서 프로세스에 대한 우선 순위를 확립하고, 메모리에 프로그램 코드를 적재하며 프로그램을 실행한다. 그 뒤 프로그램은 사용자 및 장치와 상호작용한 다음 원하는 명령을 수행하게 된다.
      
      운영체제는 프로세스[12] 들을 생성하거나 삭제하고, 중단시키거나 재개시킨다. 프로세스 간의 동기화와 통신, 교착상태 처리에 관한 메커니즘을 제공한다.
      
      사용자 및 시스템 프로세스의 생성과 종료 관리
      프로세스의 일시 중지와 속개
      프로세스 동기화를 위한 수단의 제공
      프로세스간 통신을 위한 수단의 제공
      교착 상태 처리를 위한 수단의 제공
      인터럽트
      <nowiki /> 이 부분의 본문은 인터럽트입니다.
      인터럽트는 주변 환경에 반응하고 상호작용하는 데에 효율적인 방법을 운영체제에 제공하므로 운영체제에 핵심적인 역할을 한다고 할 수 있다. 동작을 요구하는 이벤트(폴링)를 위한 다양한 소스의 입력을 운영체제가 감시할 수 있는 다른 대안은 스택이 매우 작은 구형 운영체제에서 볼 수 있으나 스택이 큰 현대의 운영체제에서는 드문 편이다. 인터럽트 기반의 프로그래밍은 현대의 대부분의 CPU에서 직접적으로 지원된다. 인터럽트는 자동으로 로컬 레지스터 컨텍스트를 저장하고 이벤트에 반응하는 특정 코드를 실행하는 방법을 컴퓨터에 제공한다. 매우 기초적인 컴퓨터들은 모두 하드웨어 인터럽트들을 지원하며 이벤트가 발생할 때 실행될 코드를 프로그래머가 지정할 수 있게 한다.
      
      프로그램이 운영체제에 인터럽트를 발생시키는 경우도 있다. 이를테면 프로그램이 하드웨어에 접근하고자 한다면 운영체제의 커널을 가로막을 수 있으며, 이를 통해 제어권을 커널에 넘겨준다. 그 뒤 커널은 요청을 수행한다. 프로그램이 메모리(또는 공유 자원)와 같은 추가 자원이 필요하면 커널이 집중할 수 있게 인터럽트를 발생시킨다.
      
      모드
      <nowiki /> 이 부분의 본문은 보호 모드 및 수퍼바이저 모드입니다.
      
      보호 모드에서 사용할 수 있는 x86용 권한 링. 운영체제는 어느 프로세스가 개별 모드에서 실행할 것인지 결정한다.
      현대의 CPU는 여러 모드의 명령을 지원한다. 이러한 기능을 지원하는 CPU에는 두 가지 모드가 있다: 보호 모드, 수퍼바이저 모드. 수퍼바이저 모드는 메모리의 기록 및 삭제 방식을 제어하는 것과 그래픽 카드와 같은 장치와 통신하는 것과 같이 운영체제의 커널이 하드웨어에 제한 없이 액세스해야 하는 낮은 수준의 태스크를 위해 사용한다. 반대로 보호 모드는 그 밖의 거의 모든 용도로 사용된다. 응용 프로그램들은 보호 모드 안에서 동작하며, 수퍼바이저 모드의 모든 것을 제어하는 커널과 통신해야만 하드웨어를 이용할 수 있다. CPU는 오래된 프로세서를 가상으로 구현하기 위한 가상 모드와 같이 보호 모드와 비슷한 다른 모드들을 지니고 있을 수도 있다. (이를테면 32비트에서 16비트 프로세서를, 아니면 64비트에서 32비트 프로세서를 가상으로 구현할 때)
      
      컴퓨터가 처음 시동할 때 자동으로 수퍼바이저 모드에서 실행된다. 컴퓨터를 켜자마다 먼저 실행되는 몇 안 되는 프로그램들이 바이오스와 부트로더이며 운영체제는 하드웨어에 제한 없이 접근한다. 그리고 운영체제가 다른 프로그램에 대한 제어권을 보낼 때 CPU를 보호 모드에 놓을 수 있다.
      
      메모리 관리
      <nowiki /> 이 부분의 본문은 메모리 관리입니다.
      멀티프로그래밍 운영체제 커널은 현재 프로그램이 이용하는 모든 시스템 메모리를 관리해야 한다. 이로써 어느 특정한 프로그램이 다른 프로그램이 이미 사용하고 있는 메모리와 상호 작용하지 않게 한다. 프로그램이 시분할하므로 각 프로그램은 메모리에 독립적으로 접근해야 한다.
      
      가상 메모리
      <nowiki /> 이 부분의 본문은 가상 메모리입니다.
      
      수많은 운영체제는 하드 디스크와 램에 분산된 메모리를 이용하여 마치 가상 메모리로 불리는 메모리 덩어리가 연속적인 것처럼 프로그램을 속일 수 있다.
      페이징이나 세그먼테이션과 같은 가상 메모리 어드레싱을 이용하면 커널은 어느 메모리를 각 프로그램이 주어진 시간에 사용할 수 있게 할지 설정할 수 있다. 그러므로 운영체제가 여러 개의 태스크에 같은 메모리 위치를 사용할 수 있게 한다.
      
      프로그램이 접근할 수 있는 메모리 범위에 없는 메모리에 접근하려고 하지만 그곳에 할당되면 커널은 프로그램이 마치 할당된 메모리를 초과 사용한 것과 같은 방식으로 인터럽트 처리한다. 유닉스에서 이러한 종류의 인터럽트를 페이지 실패라고 부른다. 커널이 페이지 실패를 감지하면 이러한 문제를 일으킨 프로그램의 가상 메모리 영역을 수정하는 것이 일반적이다. 이로써 요청된 메모리에 프로그램이 접근할 수 있게 한다.
      
      현대의 운영체제에서 자주 접근하지 않는 메모리는 일시적으로 디스크나 다른 매체에 저장하여 다른 프로그램에게 사용할 수 있는 공간을 제공해 준다. 이를 스왑 처리(swapping)라고 하며 이를 통해 여러 개의 프로그램이 특정한 메모리 영역을 차지할 수 있다.
      
      멀티태스킹
      <nowiki /> 이 부분의 본문은 멀티태스킹 및 프로세스 관리입니다.
      멀티태스킹은 여러 개의 독립적인 컴퓨터 프로그램을 하나의 컴퓨터에 실행시키는 것을 가리킨다. 마치 태스크들이 동시에 수행하는 것처럼 보여 준다. 대부분의 컴퓨터가 한 번에 최대 한 두개를 수행할 수 있고 이는 일반적으로 시분할을 통해 수행된다. 다시 말해 각 프로그램은 컴퓨터의 실행 시간의 일부를 사용한다.
      
      운영체제 커널은 스케줄러라는 프로그램이 포함되어 있는데 이 프로그램은 얼마나 많은 시간을 각 프로그램이 실행에 소비하게 할 것인지를 결정하며 여기서 실행 제어권이 프로그램에 넘어갈 수 있게 한다. 제어권은 프로그램이 CPU와 메모리에 접근할 수 있게 하는 커널로 말미암아 프로세스로 넘어간다. 나중에 다른 프로그램이 CPU를 사용할 수 있게 하기 위해 제어권은 같은 메커니즘을 통하여 커널로 반환된다. 커널과 응용 프로그램 간의 제어권 이동을 이른바 문맥 교환이라고 부른다.
      
      디스크 접근 및 파일 시스템
      <nowiki /> 이 부분의 본문은 가상 파일 시스템입니다.
      
      파일 시스템은 디렉터리(폴더)를 이용하면서 사용자와 프로그램이 컴퓨터 파일을 정리하고 정렬할 수 있게 해 준다.
      디스크에 저장된 데이터로 접근하는 것은 모든 운영체제의 기본 기능이다. 컴퓨터는 더 빠른 접근, 더 높은 신뢰성을 위해, 또 드라이브의 남은 공간을 더 잘 이용하기 위한 특정한 방식으로 구조화된 파일을 이용하여 디스크에 데이터를 저장한다. 파일을 디스크에 저장하는 이러한 방식을 파일 시스템이라고 부르며 파일이 이름과 특성을 가질 수 있게 한다. 또, 이러한 파일들을 디렉터리 트리로 정렬되는 특정 계급의 디렉터리와 폴더에 저장하게 한다.
      
      초기의 운영체제는 일반적으로 한 종류의 디스크 드라이브와 한 종류의 파일 시스템을 지원하였다. 초기의 파일 시스템들은 용량, 속도, 또 파일 이름과 디렉터리 구조의 종류에 제한이 있었다. 이러한 제한은 설계된 운영체제의 제한에 반영되므로 특정한 운영체제가 하나 이상의 파일 시스템을 지원하는 것을 매우 어렵게 만들었다.
      
      더 단순한 수많은 운영체제들은 기억 장치의 시스템에 접근하기 위한 제한된 옵션들을 지원하였는데, 유닉스와 GNU/리눅스와 같은 운영체제들은 가상 파일 시스템(VFS)이라는 기술을 지원한다. 유닉스와 같은 운영체제는 공통 API를 통해 접근하는 파일 시스템이나 디자인에 관계 없이 다양한 기억 장치를 지원한다. 그러므로 프로그램을 개발할 때 장치 접근에 대한 정보를 공부하지 않아도 되게 한다. VFS는 다양한 파일 시스템에, 특정한 장치 드라이버와 파일 시스템 드라이버를 사용하여 프로그램들이 무제한의 장치에 접근할 수 있는 기능을 운영체제에 제공한다.
      
      연결된 하드 드라이브와 같은 기억 장치들은 장치 드라이버를 통해 접근한다. 장치 드라이버는 드라이브의 특정한 언어를 이해하고 이 언어를 운영체제가 모든 디스크 드라이브에 접근할 때 사용하는 표준 언어로 번역할 수 있다. 유닉스에서 이를 블록 장치의 언어라고 한다.
      
      장치 드라이버
      <nowiki /> 이 부분의 본문은 장치 드라이버입니다.
      장치 드라이버는 하드웨어 장치들과 상호 작용할 수 있도록 개발된 특정한 종류의 컴퓨터 소프트웨어이다.
      
      장치 드라이버의 주된 설계 목적은 추상화이다. 하드웨어의 모델은, 특히 같은 종류의 장치라 하더라도 각기 다르다. 제조업체들은 더 신뢰할만한, 더 나은 성능을 제공하기 위해 더 새로운 모델들을 출시하고 이러한 새로운 모델들은 다르게 동작하기도 한다. 컴퓨터들과 운영체제들은 현재든 앞으로든 모든 장치를 어떻게 제어할 것인지 예측하는 것은 불가능하다. 이러한 문제를 해결하기 위해 운영체제들은 반드시 어떠한 종류의 장치가 제어될 것인지를 지시하여야 한다. 그러면 장치 드라이버의 기능이 이러한 운영체제의 함수 호출을 장치 특유의 호출로 번역하게 된다. 이론적으로 새로운 방식으로 제어되는 새로운 장치는 적절한 드라이버를 사용할 수 있는 상황이라면 올바르게 동작한다. 새로운 드라이버는 운영체제의 관점에서 장치가 평소처럼 동작하고 있음을 보증하게 된다.
      
      비스타 이전의 윈도우, 2.6 미만의 리눅스 버전에서는 모든 드라이버 실행이 협동적이어서, 드라이버가 무한 루프에 진입하면 시스템이 정지하는 일이 발생한다. 더 최근에 나온 운영체제들은 커널 선점을 사용한다. 이 경우 태스크 제공을 위해 커널이 드라이버를 간섭하며 장치 드라이버로부터 응답을 받을 때까지 자신을 프로세스로부터 분리시키며 더 많은 태스크를 부여할 수 있다.
      
      네트워킹
      <nowiki /> 이 부분의 본문은 컴퓨터 네트워크입니다.
      현재 대부분의 운영체제는 다양한 통신 프로토콜, 하드웨어, 응용 프로그램을 지원한다. 다시 말해, 서로 비슷하지 않은 운영체제를 실행하는 컴퓨터가 자원(유무선 연결을 이용한 연산, 파일, 프린터, 스캐너)을 공유하기 위해 같은 망에 참여할 수 있다. 네트워크는 컴퓨터의 운영체제가 원격 컴퓨터의 자원에 접근하는 데 필수적이다. 마치 리소스가 로컬 컴퓨터에 바로 연결되어 있는 것처럼 보이게 만들어 준다. 여기에는 컴퓨터의 그래픽, 사운드 하드웨어를 공유하거나 네트워킹 파일 시스템을 이용하는 등 단순한 통신에서 나오는 모든 것을 포함한다. 일부 네트워크 서비스는 컴퓨터의 자원을 투명하게 접근할 수 있게 한다. 이를테면 SSH는 네트워크로 이어진 사용자들이 컴퓨터의 명령 줄 인터페이스에 직접 접근할 수 있게 한다.
      
      보안
      <nowiki /> 이 부분의 본문은 컴퓨터 보안입니다.
      컴퓨터의 보안은 수많은 기술이 올바르게 동작하고 있는 지에 달려 있다. 또, 운영체제는 보안을 위하여 특정 환경에 대한 권한을 사용자나 프로그램에 개별적으로 설정하고 인증 프로세스를 제공한다. 인터넷 보안은 특히 여러 사용자가 사용하는 시스템에 적절하다. 시스템을 사용하는 각 사용자는 개인 파일을 다른 사용자가 읽을 수 없게 할 수 있다.
      
      사용자 인터페이스
      <nowiki /> 이 부분의 본문은 사용자 인터페이스입니다.
      
      명령 줄의 한 예. 각 명령어는 프롬프트 뒤에서 입력하면 되며 이에 대한 출력은 아래에 나타난다. 현재의 명령 프롬프트가 아래에 있다.
      
      그래픽 사용자 인터페이스의 한 예. 프로그램들은 화면 위에 그림의 모습을 띠고 있으며 파일, 폴더, 응용 프로그램들은 아이콘과 기호의 모습을 띤다. 마우스는 컴퓨터를 탐색하는 데 쓰인다.
      어떠한 종류의 입력을 받는 모든 컴퓨터는 사람이 컴퓨터와 소통할 수 있게 하는 사용자 인터페이스가 필요하다. 키보드, 마우스와 같은 장치들이 이러한 역할을 하지만 사용자 인터페이스는 이를 위한 소프트웨어로 이루어진다. 사용자 인터페이스는 역사적으로 컴퓨터 명령어를 한 줄씩 입력해 나가는 명령 줄 인터페이스와 일반적으로 창, 단추, 아이콘을 이루는 시각 환경이 존재하는 그래픽 사용자 인터페이스로 나뉜다.
      
      그래픽 사용자 인터페이스
      <nowiki /> 이 부분의 본문은 그래픽 사용자 인터페이스입니다.
      현대의 대부분의 컴퓨터 운영체제는 그래픽 사용자 인터페이스(GUI)를 지원한다. 마이크로소프트 윈도우와 맥 OS와 같은 일부 컴퓨터 시스템에서 GUI는 커널에 통합되어 있다.
      
      기술적으로 그래픽 사용자 인터페이스는 운영체제의 서비스가 아니지만 운영체제 커널에 통합하면 GUI가 출력 명령을 수행하는 데 필요한 수많은 문맥 교환을 없앰으로써 GUI를 더 반응적으로 만들 수 있다. 다른 운영체제로는 그래픽 하부 시스템을 커널과 운영체제로부터 분리시키는 모듈성이 있다. 1980년대 유닉스에서 VMS 등은 이러한 방식으로 만들어진 운영체제였다. GNU/리눅스 및 맥 OS X 또한 이러한 방식을 취한다. 윈도우 비스타와 같은 현대의 마이크로소프트 윈도우는 거의 사용자 공간에 위치한 그래픽 하부 시스템을 포함하고 있지만 윈도우 NT 4.0과 윈도우 서버 2003 버전 사이의 그래픽 구현 루틴은 거의 커널 공간에 존재한다. 윈도우 9x는 인터페이스와 커널 사이의 구별이 거의 없다.
      
      수많은 컴퓨터 운영체제는 사용자가 원하는 인터페이스를 만들어 설치할 수 있게 하고 있다. X 윈도 시스템을 GNOME이나 KDE와 함께 쓰면 유닉스 및 유닉스 계열 시스템에서 이러한 설정을 할 수 있다. 수많은 윈도우 셸 치환을 통해 마이크로소프트 윈도우에서도 이러한 작업을 수행할 수 있는데, 윈도우 셸을 교체하는 방식을 쓰지만 윈도우로부터 셸 자체를 분리할 수는 없다.
      
      실시간 운영체제
      <nowiki /> 이 부분의 본문은 실시간 운영체제입니다.
      실시간 운영체제 (RTOS)는 정해진 기간 안에 수행이 끝나야 하는 응용 프로그램을 위하여 만들어진 멀티태스킹 운영체제이다. (실시간 연산) 이러한 응용 프로그램들에는 조그마한 임베디드 시스템, 자동차 엔진 제어 장치, 산업 로봇, 우주선, 산업 제어 장치, 일부 대형 컴퓨터 시스템 등이 있다.
      
      초기의 대형 실시간 운영체제는 이를테면 아메리칸 항공과 IBM이 사브레 항공 예약 시스템을 위하여 개발한 트랜잭션 프로세싱 퍼실리티(TPF)가 있다.
      
      일부 임베디드 시스템은 실시간 연산을 지원하지 않더라도 심비안 OS, 팜 OS, BSD, GNU/리눅스와 같은 운영체제를 이용한다.
      
      취미 활동을 통한 운영체제 개발
      운영체제 개발은 컴퓨팅에 취미를 둔 사람들이 관여하는 가장 복잡한 활동들 가운데 하나이다. 취미로 만드는 운영체제는 기존의 운영체제로부터 직접적으로 코드를 가져오지 않은 것으로 분류될 수 있으므로, 사용자들과 활동 개발자들의 수는 적은 편이다.[13]
      
      취미 활동으로 개발된 운영체제의 예로는 ReactOS와 Syllable 등이 있다.
      
      시장 점유율
      <nowiki /> 이 부분의 본문은 운영 체제 시장 점유율입니다.
      2013년 운영체제별 전 세계 기기 선적량[14]
      운영체제	2012년 (단위: 100만 기기)	2013년 (단위: 100만 기기)
      안드로이드	504	878
      윈도우	346	328
      iOS/맥 OS	214	267
      블랙베리	35	24
      기타	1,117	803
      전체	2,216	2,300
      출처: 가트너
      
      리눅스 재단에 따르면 퍼블릭 클라우드 워크로드의 90%, 세계 스마트폰의 82%, 임베디드 기기의 62%, 슈퍼 컴퓨터 시장의 99%가 리눅스로 작동한다.[15]
      
      범위 및 논란
      운영체제는 잘 정의된 인터페이스를 가지므로 운영체제와 응용 프로그램 간의 구분은 명확하지만, 어느 정도의 서비스를 운영체제 안에 포함시켜야 하는가에 대한 문제는 기술적인 문제일뿐만 아니라 사업적인 문제이기도 하다. 이 문제는 다음의 경우에 분명히 드러난다. 1998년 미국 법무부는 마이크로소프트에 대해 소송을 제기하였는데, 요점은 마이크로소프트가 운영체제에 너무 많은 기능을 포함시켜 응용 프로그램 제작업체들에게 피해를 주었다는 것이다.
      
      같이 보기
      운영체제의 역사
      운영체제 목록
      운영 체제 최적화
      모바일 운영 체제
      범용 운영 체제
      전용 운영 체제
      실시간 운영 체제 (RTOS)
      임베디드 시스템
      객체 지향 운영 체제`,
    },
    {
      id: 24,
      title: "네트워크",
      contents: `네트워크(network), 망(網)은 다음을 가리킨다.

      통신망
      통신 네트워크(telecommunications network)
      컴퓨터 네트워크(computer network)
      무선 네트워크(wireless network)
      방송망, 중계망
      방송 네트워크(broadcasting network)
      라디오 네트워크(radio network)
      텔레비전 네트워크(television network)
      그래프 이론
      네트워크 과학
      경제
      네트워크 효과
      기술, 컴퓨터 과학
      뉴럴 네트워크(neural network)
      소셜 네트워크(social network)
      전기 회로(electrical network)
      영화
      《네트워크》(network) - 1976년 미국 영화
      《네트워크》(network) - 2013년 영화
      기타
      네트워크 뮤직 그룹(Nettwerk Music Group)
      영업망, 교통망
      네트워크 (신문)
      같이 보기
      제목에 "네트워크" 항목을 포함한 모든 문서`,
    },
  ];
  return originData;
}
